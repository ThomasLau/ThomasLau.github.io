<!doctype html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ratelimiter,guava,Leaky," />





  <link rel="alternate" href="/atom.xml" title="e+Thomas" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon32.ico?v=5.1.1" />






<meta name="description" content="intro1：限流的常见实现方式及常见开源限流组件有注意点intro2: 你真的理解了漏桶和令牌桶限流算法吗，划分/区分二者科学吗intro2: 你知道限流保障服务可用时也可能导致其他服务不可用吗  早先看到朋友圈分享限频限流的文章，从中有些收获，不过笔者不打算赘述，想进一步探讨下限频限流，以及限频限流使用时可能遇到的问题，同时也是对前一篇博文的回应，或许看完本文你会对Guava令牌桶算法有不一样">
<meta name="keywords" content="ratelimiter,guava,Leaky">
<meta property="og:type" content="article">
<meta property="og:title" content="对限频限流的思考">
<meta property="og:url" content="http://thomaslau.github.io/2020/05/10/2020-05-10-on_ratelimiter/index.html">
<meta property="og:site_name" content="e+Thomas">
<meta property="og:description" content="intro1：限流的常见实现方式及常见开源限流组件有注意点intro2: 你真的理解了漏桶和令牌桶限流算法吗，划分/区分二者科学吗intro2: 你知道限流保障服务可用时也可能导致其他服务不可用吗  早先看到朋友圈分享限频限流的文章，从中有些收获，不过笔者不打算赘述，想进一步探讨下限频限流，以及限频限流使用时可能遇到的问题，同时也是对前一篇博文的回应，或许看完本文你会对Guava令牌桶算法有不一样">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://thomaslau.github.io/images/leaky_token_buket.png">
<meta property="og:updated_time" content="2020-05-10T19:28:36.916Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="对限频限流的思考">
<meta name="twitter:description" content="intro1：限流的常见实现方式及常见开源限流组件有注意点intro2: 你真的理解了漏桶和令牌桶限流算法吗，划分/区分二者科学吗intro2: 你知道限流保障服务可用时也可能导致其他服务不可用吗  早先看到朋友圈分享限频限流的文章，从中有些收获，不过笔者不打算赘述，想进一步探讨下限频限流，以及限频限流使用时可能遇到的问题，同时也是对前一篇博文的回应，或许看完本文你会对Guava令牌桶算法有不一样">
<meta name="twitter:image" content="http://thomaslau.github.io/images/leaky_token_buket.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thomaslau.github.io/2020/05/10/2020-05-10-on_ratelimiter/"/>





  <title>对限频限流的思考 | e+Thomas</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?22bda74eb54c0d90672fd5c06458004c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">e+Thomas</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thomaslau.github.io/2020/05/10/2020-05-10-on_ratelimiter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Thomas Lau">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myLogo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="e+Thomas">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">对限频限流的思考</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T10:59:10+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote><p><i><strong>intro1</strong>：限流的常见实现方式及常见开源限流组件有注意点</i><br><i><strong>intro2</strong>: 你真的理解了漏桶和令牌桶限流算法吗，划分/区分二者科学吗</i><br><i><strong>intro2</strong>: 你知道限流保障服务可用时也可能导致其他服务不可用吗</i></p>
</blockquote>
<p>早先看到朋友圈分享限频限流的文章，从中有些收获，不过笔者不打算赘述，想进一步探讨下限频限流，以及限频限流使用时可能遇到的问题，同时也是对前一篇博文的回应，或许看完本文你会对Guava令牌桶算法有不一样的理解。<br><a id="more"></a></p>
<h2 id="什么是服务限流限频？"><a href="#什么是服务限流限频？" class="headerlink" title="什么是服务限流限频？"></a>什么是服务限流限频？</h2><p>先看 <strong>流量整形</strong>(traffic shaping)这个概念，wikipedia解释是一种控制网络数据包传输的技术，通过控制数据速率使数据较为均匀发送。流量整形可以一定程度减少网络拥塞，并减弱突发流量带来的影响。<br>对于像一个操作数据库的接口、甚至google查询、微信加好友等各种系统服务来说，也需要对请求进行频率控制，这类限频的思想就来自于流量整形，漏桶和令牌桶限流算法即是源自于流量整形衍生。<br>对服务的频控，具体到不同的实现大同小异，如<br>Guava doc对限频（RateLimiter）的理解是 <strong><em>在一个指定的速率上分发许可（permit）,当每次来请求的时候，线程会阻塞，直到获取到可用的permit，使用完这些permit之后不需要进行释放的操作</em></strong><br><em>本文暂且认为限频/限流/频控/流量整形是同一个概念</em></p>
<p>限频显然关键的一点是频率，包括频率大小以及频率计算方式，但还有一点是针对谁限频，即限频的key，常见的如path(url)、ip、api、method、uid等各种维度，似乎没有文章讨论过这一点，但是重要的，下文会讨论。<br>其实考虑到流量整形，限频还有一点要考虑，就是对 均匀 的定义，现实请求是离散又连续均匀的，比如某类请求从每分钟维度统计是均匀的，但可能具体到每秒每0.1秒可能就不是，下文也会提及这点。<br><strong>但不管如何划分，限频的本质是对一类周期性共享资源的使用</strong>。</p>
<h2 id="限频的-Key-设计"><a href="#限频的-Key-设计" class="headerlink" title="限频的 Key 设计"></a>限频的 Key 设计</h2><p>不论何限频组件/算法，都要面临对限流限频资源即key的选择，key虽简单，但重要。<br>像静态的基于API/PATH/METHOD，或者动态uid/ip/cookie等，他们有什么不同呢？</p>
<p>笔者认为限频也可以按功能分为服务限频和业务限频，即针对Key的不同分为：</p>
<ul>
<li>服务限频<br>像同一个接口/path等通常操作同一类资源，显然需要有频率来控制对后端资源的访问。<br>这也即现代大多数网关Gateway/Service Mesh等容器/技术会提供的，可以透明实现的而无需业务方实现。</li>
<li>业务限频<br>用来防止某些人恶意刷接口的，如最简单的根据用户请求某类接口来限制频次(当然简单的可归类于服务，但如复杂需侵入业务的需求则否）。</li>
</ul>
<p>服务限频通常根据 接口名/url(request path)这类常量限制，业务限频则是动态的uid、ip、cookie值、甚至地区等，服务限频只能起到保证整体的后端服务可用，不能防止恶意用户刷频，比如某接口限频100次/分钟，用户A访问刷频了99次，那么其他所有用户该分钟內只能访问1次了，基于uid的业务限频可以避免该类问题，但业务限频不能进行服务限频保证后端服务。</p>
<p>此外，上述限频可以认为默认皆同步实现，假设有的需要业务之间调用并计算才能得到次数，比如用户当天下单优惠次数，比如用户某类接口成功次数，用户每分钟调用接口A和B加起来不能超过多少次，这些需要渗入业务结果，或者通过大数据业务计算出超频的用户，推送给接口限频，对这类限频需求，笔者定义为异步业务限频，当然这存在之后滞后的问题。<br>像Nginx/lstio/linkerd/springcloud都提供了服务限频，而springcloud默认通过配置也即可支持基于uid等业务限频，有些大公司实现的网关也是支持服务和业务(如用户唯一标识)的，如Dubbo的限频Tpslimiter就是仅对service key即接口类限频，而SpringCloud Alibaba 通过Sentinel则支持更丰富的服务/业务限频策略。</p>
<p>服务或业务限频，同步或异步计算各有优劣和不足，但直接公开的服务，如果没有业务限频而只有服务限频存在刷频风险。对于实现限频的方式来说，基于接口/path的服务限频，存在热点问题，基于uid级别限频则可能耗费存储，而且是限频的接口数X每秒(分钟)內活跃用户数的量级。</p>
<h2 id="限频实现的几种技术"><a href="#限频实现的几种技术" class="headerlink" title="限频实现的几种技术"></a>限频实现的几种技术</h2><p>上述限频按功能分类，这里聊聊按实现算法分类。<br>这里几个较可信网站的文章，<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673" target="_blank" rel="external">分布式服务限流实战</a>, <a href="https://www.infoq.cn/article/microservice-interface-rate-limit" target="_blank" rel="external">微服务接口限流的设计与思考</a>，把限频实现做了分类，分为：<br><strong>信号量、计数器、固定窗口、滑动窗口、漏桶算法(Leaky Bucket)、令牌桶算法(Token Bucket)、分布式限流。</strong><br>以下内容假设读者对此稍微了解。<br>实际上，更早一篇来自网关Kong的文章 <a href="https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm/" target="_blank" rel="external">How to Design a Scalable Rate Limiting Algorithm</a>，也有此分类，Kong本身使用的是<a href="https://github.com/Kong/kong/blob/0f2d77b678624b0383c0c80c01319cdee5b65cdb/kong/plugins/rate-limiting/policies/init.lua" target="_blank" rel="external">计数法</a>。<br>信号量主要用来控制并发数，本文不做讨论。<br>原文对滑动窗口描述简略，这里补充下：假设限频每分钟100次，一般滑动窗口是将1分钟分割多个单位时间，比如分割为10个窗口，即每6秒滑动一个窗口，统计时间范围也相应后移动。次数不需要每窗口均匀的，也可以多个滑动窗口，比如同时加一个每12秒也可，这样实现每6秒不超过x次每12秒不超过y次。<br>固定窗口/滑动窗口是一类好理解，但计数器和窗口也是一类，都是累计次数的做法（而令牌桶/漏桶归为桶限流），滑动窗口是更细粒度的计数器/固定窗口，如上分析也是可以支持突发流量，Hystrix停更后建议的替代者resilience4j 默认<a href="https://github.com/resilience4j/resilience4j/blob/master/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java" target="_blank" rel="external">AtomicRateLimiter</a>即是该做法：<br><em>Our RateLimiter is not an implementation of a leaky bucket algorithm which leaks out at a constant rate. It uses a fixed window algorithm which can have burst effects at time window boundaries.</em><br>见<a href="https://github.com/resilience4j/resilience4j/issues/336" target="_blank" rel="external">issue-336</a>。<br>代码略繁，AtomicRateLimiter类变量nanoTimeStart为初始化时间，在计算当前时间窗口时以此为起点（nanoTime() - nanoTimeStart），在acquirePermission时因为burst会有其他计算但基本以时间窗口内累计permits为准，这和下文要分析的令牌桶/漏桶异曲同工。<br><em>需要指出Sentinel官方wiki的 从 <a href="https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel" target="_blank" rel="external">Hystrix 迁移到 Sentinel</a>提到的 滑动窗口LeapArray、Ring Bit Buffer(滑动窗口演变)是其统计请求量/成功量/错误失败量的实现，而不是限频算法的实现，和<a href="https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingNumber.java" target="_blank" rel="external">Hystrix的滑动窗口</a> 实现数据平滑统计类似，但Hystrix只起统计参数作用不参与限频，而Sentinel不仅统计频率提供给StatisticSlot模块使用，还会更新至Node并参与下一次限频(下文提及)。Hystrix 就是将执行结果存储在10个长1秒的时间窗口中，每秒增删来更新窗口，统计数据从这类窗口得出，Sentinel默认似乎仅两个，但默认保持一分钟的。为什么要用滑动窗口记录这类数据而不是直接更新，甚至Sentinel还为此优化高效LeapArray？笔者未能从三者文档/代码或其他文章找到，不过大胆猜测可能初衷是希望借鉴EWMA计算均值的想法。</em><br>Hystrix可以有限的做过载保护削峰，基于信号量做线程隔离/控制并发数，没有真正的限频限流机制，故本文不再讨论 Hystrix（<a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94" target="_blank" rel="external">Sentinel 与 Hystrix 的对比</a>）。</p>
<p>Dubbo的限频 DefaultTPSLimiter 可以自定义时间间隔(不考虑gc可以到1毫秒)，即该时间间隔内不超过设置的次数，即其本质是计数法，而不是自称的漏桶，像lyft/ratelimit也是计数法基于redis分布式。<br>笔者记得曾听过淘宝系分享早期限频就是用 计数法 + guava map实现的LRU缓存。<br><strong>不过滑动窗口计数的思想，非常适合流计算工具去计算频率</strong>，下面storm/kafka部分会提及。<br>Nginx和阿里的 Sentinel 都实现了漏桶算法，Springcloud Gateway和Guava Ratelimiter实现了令牌桶。</p>
<p><strong>上述限频方式虽然有优劣，但更有各自的适用场景，比如要求每分钟不超过60次，可以不均匀，使用计数法是比较好的，而漏桶和令牌环都做不到恰好60，因为允许突发。</strong><br><strong>同时，限频限流也不只上述几个分类</strong>，我们甚至可以任意实现有别上述几类的限频方法，比如上述计数法的两个窗口都是基于时间的窗口（时间片），我们也可以基于请求的窗口，即维护一个队列，如每分钟限制100次，那么维护队列最长1000，当请求时判断是否超1000，如否放行并追加末尾，否则取头元素时间并判断是否超一分钟：1)如否，表示已满则拒绝该请求，2)否则，放行并删头追加末尾。该方案同计数法但可以无锁，只是耗内存。<br>分布式限流一般是计数/桶算法的分布式版本，故不提。<br>上面计数法显然默认不支持的流量整形，token支持流量整形，而leaky默认否，但下文分析其例外情况。<br>下面让我们重点看剩下的leaky和token算法</p>
<h2 id="漏桶-Leaky-Bucket-令牌桶-Token-Bucket-是否值得区分"><a href="#漏桶-Leaky-Bucket-令牌桶-Token-Bucket-是否值得区分" class="headerlink" title="漏桶(Leaky Bucket)/令牌桶(Token Bucket)是否值得区分"></a>漏桶(Leaky Bucket)/令牌桶(Token Bucket)是否值得区分</h2><p><em>这段分析认为leaky/token差别只是概念上的，实现上区分无意义，较长，不兴趣可不读，跳到下一节。</em><br>看完上述分类，读者有想过自己真的了解上述分类吗？leaky和token真的有区别吗？</p>
<h3 id="真实的流量"><a href="#真实的流量" class="headerlink" title="真实的流量"></a>真实的流量</h3><p>笔者认为上述分类是混乱的，区分leaky和token不是那么必要。<br>在讨论leaky和token时，大家会经常看到漏桶滴水的两张对比图，即两图实际用水流/水滴模型，<a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="external">wikipedia这里也有详细介绍</a>。<br>限流通常是因为服务性能有限而要求，但也会被用来纯粹的限制次数需求(防ddos/防薅羊毛等)，而限频使用何种处理方法则是因为真实的请求是离散而时间是一定程度上连续导致。我们先抛开水流，看下真实的请求需要怎么处理：</p>
<p>假设时间最小精度是1秒，需求是限制1分钟处理600个请求，如果不关心出现600个请求1秒处理完，那么使用基于1分钟的计数做法没有问题，这么做达到需求的限频目的，但是对服务限频而言没有，因为可能出现第59-60秒处理600个，甚至下一轮00-01秒也处理600个，即极端情况1秒处理1200个了，对服务来说不希望看到，当把计数的窗口缩小，即每6秒钟重置，也就是把60秒切分10份，每份不超过60(600/10)个请求，此时极端情况1秒处理120了…当划分越细到最小1秒，极端就是每秒20个，但此时存在1秒内不处理请求也就越明显此时划分就类似放token，但目前都是计数法，按窗口计数真正的请求。<br>真实请求不是均匀的，比如第2秒20请求过来，接下来3-60秒可能都没有数据，按计数法会拒掉10个，但考虑到后续空闲，拒掉是浪费，是否可缓冲到第3秒执行，即占用下时间片的额度？这里涉及历史状态，为简化，只记录上一次状态（时间或量），以及一个burst量，像guava限频就记录上次请求时间。</p>
<p><a href="http://www.cs.ucc.ie/~gprovan/CS6323/2014/L11-Congesion-Control.pdf" target="_blank" rel="external">这是笔者搜到的图</a>，对比常见水流模型二图，该图其实更易理解leaky/token的不同<br><img src="/images/leaky_token_buket.png" width="100%"></p>
<h3 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h3><p>上述放入token的情景，换种思路，假设请求是均匀的，<strong>即把每个时间片等同于一个token</strong>，那么通过计算时间差就可以得到该周期内(秒/分钟…)已经发放的token，Token Bucket即是如此，通过控制发放（token）permit方式控制permit被消费速度（即限频），但一般不会用后台线程每 1/n 秒将 bucket 中的 token 数量加一，而是上述计算时间差，得到该时间差內增量token，加上次剩余的 token （二者不超过 bucket 容量限制），然后比较剩余token 数是否满足需要。<br>这种逻辑是依据排队理论中的 <a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="external">Little’s law</a><br>对于一个稳定的系统中，长期的平均顾客人数，等于长期的有效抵达率（λ），乘以顾客在这个系统中平均的等待时间（W），反过来，平均等待时间就是平均顾客数除以有效抵达率。<br>Guava限频/Sentinel就是基于token bucket算法，支持一定的burst，其中SmoothWarmingUp还支持平滑预热的burst，Guava Ratelimiter本质把限频转换成一种排队现象，每次请求返回的实际是下一轮请求需等待(permits)的时间。guava的burst支持即刻或者预热，即刻并不友好，而且burst量默认是一秒的，如果aquire的不是每次一个还是有害的，预热通过线性放量可以定量的缓解，当然如果你想指数级放量也未尝不可，对warmup机制感兴趣参考这篇 <a href="https://mp.weixin.qq.com/s/Mj9TG0e71uoN-W1H1JRHJA" target="_blank" rel="external">源码分析RateLimiter SmoothWarmingUp 实现原理</a></p>
<h3 id="leaky-token是否值得区分"><a href="#leaky-token是否值得区分" class="headerlink" title="leaky/token是否值得区分"></a>leaky/token是否值得区分</h3><p>我们先看经典的Nginx限频限流怎么做的。<br>Nginx可以分别分为针对并发连接数和针对请求（QPS）进行，基于Nginx的扩展OpenRest的<a href="https://github.com/openresty/lua-resty-limit-traffic/blob/master/lib/resty/limit/req.md" target="_blank" rel="external">lua-resty-limit-traffic</a>模块基于redis支持分布式支持leaky/token两种限频，不过这里和Nginx基于并发连接数（limit_req_conn）限频都不讨论，主要看Nginx基于QPS的限频limit_req_zone。<br>如下配置一个基于ip的限频，每秒20次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">  ...</div><div class="line">  limit_req_zone $binary_remote_addr zone=allips:10m  rate=20r/s;</div><div class="line">  server &#123;</div><div class="line">    ...</div><div class="line">    limit_req  zone=allips  burst=5  nodelay;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Nginx自身有的请求限制模块<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external">ngx_http_limit_req_module</a>，正如其描述Nginx基于leaky bucket限频。<br>题外话，Nginx限频缺点是：配置不适合动态修改，存储是单机内存，即不是跨机器共享分布式，内存占用大需要考虑（如上述基于ip 限频64 bit，1M最多能存储16000个，状态指的就是key，nginx有根据LRU优化，但毕竟可能数据不全）。其次，如果你有Nginx实现基于区域的限频，可以试试ip转区域的插件IP2Location Nginx Module。<br>注意上述“burst=5  nodelay”，表示处理突发请求不超过5个，如果不配置nodelay，那么请求会排队等到下一秒，配置nodelay表示可以立即执行(但不超过bust数)，可以看到虽然基于Leaky，但是Nginx限频还是支持突发流量的。</p>
<p><a href="https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_limit_req_module.c#L411" target="_blank" rel="external">Nginx 漏桶算法代码</a>，可以看到Nginx leaky也是把permit等同于时间片的，那么思考个问题：<br><strong>在水流模型中流入和流出分别是什么？把permit等同于时间片，是否兼具流入和流出的角色</strong>？</p>
<p>如果读者认定Leaky不允许突发“Doesn’t allow bursty transmissions”，即 <em>它们之间最主要的差别在于：漏桶算法能够强行限制数据的传输速率，而令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输</em>，那么Nginx/Sentinel/Guava都不是leaky，就比较像token了，这时 <a href="http://www.cs.ucc.ie/~gprovan/CS6323/2014/L11-Congesion-Control.pdf" target="_blank" rel="external">“For this purpose we use a token bucket, which is a modified leaky bucket”</a>。</p>
<p>不过<a href="https://github.com/mailgun/gubernator" target="_blank" rel="external">Gubernator</a> 确实是按照这点来区分的，分别实现了leaky/token算法，正如其备注的 “Leaky Bucket is implemented similarly to Token Bucket where OVER_LIMIT is returned when the bucket is full。”</p>
<p>Sentinel文档里作者认为Guava像leaky bucket，自己<a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8" target="_blank" rel="external">更像是token bucket</a>，而大部分中文提及Guava是token bucket，<strong><em>不过如果看guava源码/doc，作者没有甚至都未提过token或leaky bucket</em></strong>，在doc里作者阐述了流入的是均匀token[permits]的设计思想，但没有提及token bucket说法。<br>需要指出的是Sentinel的RateLimiterController是leaky算法。</p>
<h3 id="wikipedia的解释"><a href="#wikipedia的解释" class="headerlink" title="wikipedia的解释"></a>wikipedia的解释</h3><p>维基百科对leaky与token的关系做了对比：<br><a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="external">https://en.wikipedia.org/wiki/Leaky_bucket</a></p>
<p><em><strong>The leaky bucket as a meter is exactly equivalent to (a mirror image of) the token bucket algorithm</strong>, i.e. the process of adding water to the leaky bucket exactly mirrors that of removing tokens from the token bucket when a conforming packet arrives, the process of leaking of water from the leaky bucket exactly mirrors that of regularly adding tokens to the token bucket, and the test that the leaky bucket will not overflow is a mirror of the test that the token bucket contains enough tokens and will not ‘underflow’. Thus, given equivalent parameters, the two algorithms will see the same traffic as conforming or nonconforming. <strong>The leaky bucket as a queue can be seen as a special case of the leaky bucket as a meter.</strong></em><br>…<br><em>In fact both are effectively the same, i.e. implementations of both the leaky bucket and token bucket, as these are the same basic algorithm described differently. This explains why, given equivalent parameters, the two algorithms will see exactly the same packets as conforming or nonconforming.</em><br>leaky算法分为as a queue和as a meter，as a queue可以堪称as a meter的特例(一个单位的延迟)，不过原文确实提及as a queue不存在突发,防抖动，<br>as a meter的leaky和token算法本质同只是描述不同。</p>
<h3 id="进一步理解限频"><a href="#进一步理解限频" class="headerlink" title="进一步理解限频"></a>进一步理解限频</h3><p>笔者觉得可以把限频限流分成两部分来看：</p>
<ul>
<li>计频：该部分功能是计算qps，对计数类就是当前时间段內累积次数，对leaky/token是该周期内permits。</li>
<li>控频，或限频策略，即超频时触发何种操作。</li>
</ul>
<p>控频分拒绝、等待、预热放行，或如Sentinel的策略 拒绝、Warm Up、匀速排队，nginx、guava、springcloud等部分支持。<br>这样上文提到的几个分类算法，可以认为是计频和控频实现方式的组合。</p>
<h2 id="控频"><a href="#控频" class="headerlink" title="控频"></a>控频</h2><p>介绍下几个组件对超频的处理：<br>Guava限频时，中aquire接口超频阻塞，而tryAquire接口则支持立即或超时后拒绝。<br>Sentinel支持阻塞、立即或超时后拒绝，具体DefaultController-默认处理策略，直接拒绝处理，RateLimiterController-匀速排队，WarmUpController-预热/冷启动方式，WarmUpRateLimiterController-预热+匀速排队，但Sentinel同时包含flowrule配置规则的处理。<br>而spring-cloud-gateway redis限频则直接拒绝，只不过会返回等待的时间tokensLeft。<br>Guava ratelimiter融合了令牌桶限频算法和超频处理的逻辑（了解这点，读guava代码就会更容易理解），如果你只是希望理解令牌桶限频，那么spring-cloud-gateway redis脚本就很简洁，而且目前只有setex操作，性能高，相比笔者曾见过的某司基于redis仿Guava限频算法包含hset/hget操作的脚本性能强多了。<br>但是，如springcloudgateway只能直接拒绝这类是起不到流量整形作用的，但流量整形直接暴露公网存在服务阻塞问题，下文会提及。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>需要指出的是，上文真实放Token的做法并非不可取，像guava实现令牌桶是线程安全的，每次aquire一个token都是synchronized的，而计数法的cas/或CLH锁等，不过在笔者老旧Mac上50-100线程內并发都是可以达到单机十万每秒吞吐，性能尚可。而真实放token的实现方式可能会更快，如使用Disruptor无锁方式，只是空间耗费了。<br>像Sentinel自述warmup几个限频类是参考Guava实现，但去掉了synchronnized，笔者没有完全阅读这块代码，<strong>不过无锁的几个方法应该是存在非线程安全导致限频计算错，但正如其doc提到，实现的是限频这种操作/趋势，对精确性要求不高</strong>。</li>
<li>如有的说法“令牌桶是你能承受突发流量，漏桶是你无法承受”这种说法其实是模糊的，我们服务限流大多是无法承受突发流量，但业务(如基于uid)限流是可以承受突发的-但这也是在假设用户是非恶意用户的情况下，我们可以根据服务/业务设置不同的leaky/token，但理解算法本身时，没必要区分。</li>
<li>笔者没有仔细阅读Sentinel源码，所以再简单探讨下Guava的SmoothWarmingUp和Sentinel的WarmupController的区别，不保证对。<br>Guava 在于控制获取令牌的速率，即获取permits的时间storedPermitsToWaitTime，通过storedPermits以及freshPermits的过程，推算出 nextFreeTicketMicros，即关注/返回的始终是下一次permits需等待的时间，这个nextFreeTicketMicros就是上文说的guava需要的上一次状态，只不过guava提前了，因为guava acquire放行的原则就是尽量提前。<br>而Sentinel目的在于控制QPS，而且主要是passQps，首先对于存在某些异常调用更准确些，其次，QPS是历史数据，比Guava只有上一次状态更能做到均衡，像WarmupController还用到了previousPassQps，看起来通过历史数据想实现更精准些，包括QPS影响token存储量，同时Token开始增长时间也受QPS影响，频率计算跨越太多的类，影响条件也多，绝不是其注释提到的公式那么简单。<br>总之，看下来，个人认为 WarmupController 通过 warningToken 比guava能更早更充裕时间的应对流量突发，而通过warningQps看起来能使该过程更平稳，个人认为对服务而言可能比SmoothWarmingUp更友好。</li>
<li><a href="https://patents.google.com/patent/CN1536815A/zh" target="_blank" rel="external">工业上的限频</a>不仅上述几种，比如上述令牌桶被称为单桶单速，可以扩展单速双桶, 双速双桶等，单速双桶，顾名思义，比令牌桶多了一个桶，可以拿高速路汽车限流举例，红黄绿三灯划分两桶，就像流量被染色，绿桶全放行，黄桶等绿桶，分别用于处理量突发和速率突发的算法，笔者没有兴趣就不深入了。<br>总之我们需要具体情况具体分析，只有最合适没有普适且最优的。</li>
</ol>
<h2 id="限频限流注意事项"><a href="#限频限流注意事项" class="headerlink" title="限频限流注意事项"></a>限频限流注意事项</h2><p>使用限频限流注意事项笔者不赘述，这里讨论两点：<br>1）可以参考前一篇博文 <a href="http://thomaslau.xyz/2020/04/22/2020-04-22-spring_cloud_gateway_redisratelimit_issue/" target="_blank" rel="external">Springcloud Gateway Redis限频失效</a><br>补充下：<br>a）考虑到时间误差，是因为虽然可ntpdate等较时，但RTC时间存在误差，差0.1秒就能有10%误差，而有些廉价主机可能每天1+秒差。<br>b）其次收到反馈：<br>脚本在setex这个写入命令前使用了time命令，产生副作用，需要加 <strong>redis.replicate_commands()</strong> 。在3.2-4.x版本是需要加的，而且也可以如下避免频繁操作也会产生大量主从复制(对了，<strong>redis现在已经没有slave说法</strong>了)操作/流量：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis.replicate_commands()</div><div class="line">redis.set_repl(redis.REPL_NONE)</div></pre></td></tr></table></figure></p>
<p>需要再指出的是5.0之后不需要加了，实际上几年前antirez就此讨论过，<strong>而2018年<a href="https://www.redis.com.cn/commands/eval" target="_blank" rel="external">5.0版</a>后的Redis已经修改脚本复制为默认按<a href="https://github.com/antirez/redis/issues/5292" target="_blank" rel="external">效果复制</a></strong>，这里是代码改动 <a href="https://github.com/antirez/redis/commit/7895835df6aeb2a2d499bc499ae6cb340228908f" target="_blank" rel="external">Use commands (effects) replication by default in scripts</a>，<a href="http://antirez.com/news/97" target="_blank" rel="external">这里作者讨论涉及初衷</a>，在<a href="https://github.com/antirez/redis/issues/5292" target="_blank" rel="external">issue-5292</a> 里作者做了讨论，针对过去面临的一些问题和不足，<strong>认为自己考虑不周，Redis lua存在设计错误，认为应该只允许效果复制</strong>：<br><em>All those considerations make me think that there is a design error in Redis currently. I believe that we should only allow effects replication, and totally remove the previous mechanism to replicate the script verbatim.</em><br>即，<strong>5.0之后，redis lua脚本已经默认支持一些副作用的命令后加set类写操作了</strong>，这点可能大多忽视了。<br>2）nginx/sentinel存在时间回退导致限频不准。<br>在通过时间差计算Token/permits时，像Guava ratelimiter <strong>使用nanotime作为计时器而不是currentTimemillis</strong>，这是为了控制更精确吗？<strong>不是</strong>，<strong>纳秒是为了防止时间回拨</strong>，时间回拨时这段时间结果是不对的，所以你看到网上模拟token或leaky使用毫秒，实现都是可能出现该问题的。<br>同样Sentinel也存在并发的可能，不过如其所言，实现的是限频的趋势/效果，容许几次偏差。<br>3）热点数据<br>前文亦提过，这里补充下：<br>redis 单机set/get操作性能在十几万级别，<strong>antirez的<a href="https://redis.io/topics/benchmarks" target="_blank" rel="external">redis-benchmarks 约12万/s</a></strong>。<br>热点数据容易带来尖刺，笔者在做某外卖公司的风控平台时曾对一个不大数据量的sortedset压测，削峰并不容易。<br>Gubernator就认为redis管道或lua脚本耗时操作，提出了本地cache存储限频数据的方案。<br>基于用户级别的限频，Sentinel比guava实现要耗内存，不过阅读Sentinel官方文档，笔者发现其提供了热点参数限流的功能，可以基于LRU策略统计最近访问频次高的uid，看起来似乎少量内存即可实现限流 top K的用户。</p>
<p>提供个信息：十万QPS对有些企业完全不够，几年前的微信摇一摇春晚红包已经是1400万次/秒的QPS级别，用户之间的红包是每秒钟收发40万，oceanbase在双十一期间也曾达6千万每秒操作。</p>
<p>4）<strong>限频可能会耗尽服务线程池，或者说，最小限频吞吐量可能成为你的整个系统吞吐量</strong>。<br>如果使用guava aquire()接口，而不是 tryAquire()，那么因为该接口有sleep操作，并且没有时间限制，当达到限频时你的线程就开始sleep了，如果请求不断的进来，那么可能线程大部分时间都在sleep了，而我们的服务如Dubbo/Tomcat/Jetty等容器都是共用请求线程池的，导致服务的其他接口请求可分配线程资源就少了，甚至没有。<br>想清楚这点并不难，如Tomcat，虽然请求httprequest会作为FIFO队列被线程池消费，只要有一个活跃的线程，总会拿到限频的请求，此时因超频sleep，整个容器无法服务。<br>可以试验看到，假设某接口使用guava的aquire限频1秒钟5次，假设burst 5，tomcat配置200线程，<strong>那么我只要以210次每秒请求该接口就能导致整个Tomcat 200个线程都在sleep约1秒，整个服务不能响应</strong>。<br>所以要用 tryAquire 接口，并且不设置最大等待时间，直接拒绝。</p>
<p>阿里的Sentinel中WarmUpRateLimiterController/RateLimiterController/RateLimiterController都有sleep阻塞，DefaultController默认是直接拒绝的，但是是Priorited的请求SphU.entryWithPriority()是阻塞的。</p>
<p>除非我们将这些限频的请求转入自定义的线程池，像netty我们可以直接把某类handler指定EventExecutorGroup,jetty/tomcat就麻烦些了，这属于长/短链接(请求)处理的问题，不展开探讨，当然纤程（Coroutine）可能也是一种解决方案。<br>说到netty异步，一句题外话，java社区曾热衷异步/响应式编程，笔者不久前看到jdbc异步（ADBA）的文章，不过异步实现是难的，oracle去年已经停掉了 ADBA项目，Spring Pivotal工程师则推出了响应式的 R2DBC, 本文并非比较此，但如社区讨论：<br><em>The only reason to write async code is that threads are so expensive.<br>Project Loom will add fibers<br>No need to learn a new API. Existing code can be made to work with few if any changes<br>In the long term fibers are the answer but that’s a couple of years away.</em><br><a href="https://mail.openjdk.java.net/pipermail/jdbc-spec-discuss/2019-September/000529.html" target="_blank" rel="external">推荐fiber</a>，<a href="https://technology.amis.nl/2020/04/10/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc/" target="_blank" rel="external">这里有一个性能对比</a> </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后，业务计频有怎么做呢？<br>像Spark/KafkaStream/Flink/Storm等流计算工具，都提供了基于流的操作，比如读取应用到文件log、网络端口传输的数据、kafka等mq事件，对于流操作，不仅包含类似groupby/mapreduce这类操作，也支持time window概念，非常适合。</p>
<p>比如，Storm支持从时间或数量上来划分，通过窗口的长度/滑动间隔有不同的如，Sliding Window（滑动窗口）按照固定的时间间隔或者Tuple数量滑动窗口（重叠或间隔），也有Tumbling Window（滚动窗口），如实现统计60s内每10s的xxx。<br><em>topologyBuilder.setBolt(“bolt”, new XXXWindowBolt().withWindow(<br>BaseWindowedBolt.Duration.seconds(60), BaseWindowedBolt.Duration.seconds(10))).shuffleGrouping(“spout”);</em></p>
<p>同storm，kafka-stream也通过Timewindow和commit interval，二者组合起来实现滑动窗口(slice window)，即每commit interval去上报统计该Timewindow 之内统计到的次数。<br>Spark-Streaming的reduceByKeyAndWindow算子也可以实现类似功能，只不过其对Time window的处理和kafka-stream不同，和storm同。Flink也有类似功能。<br>这里推荐笔者之前一篇<a href="/2019/09/13/2019-09-13-how_to_group_twice_in_kafkastreams">kafka-stream的group by 操作的文章</a></p>
<p>最后希望看完本文后 希望你除了知道”接口要加限流保障服务平稳运行“，还能进一步考虑下这么加限流是否可行/是否会影响其他服务不可用。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ratelimiter/" rel="tag"># ratelimiter</a>
          
            <a href="/tags/guava/" rel="tag"># guava</a>
          
            <a href="/tags/Leaky/" rel="tag"># Leaky</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/22/2020-04-22-spring_cloud_gateway_redisratelimit_issue/" rel="next" title="Spring Cloud RedisRateLimit限频存在的几个问题">
                <i class="fa fa-chevron-left"></i> Spring Cloud RedisRateLimit限频存在的几个问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/20/2020-05-20-on_hash_1/" rel="prev" title="开发中常见的一些Hash函数（一）">
                开发中常见的一些Hash函数（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/myLogo.png"
               alt="Thomas Lau" />
          <p class="site-author-name" itemprop="name">Thomas Lau</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ThomasLau" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/liuyongzhi0218" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是服务限流限频？"><span class="nav-number">1.</span> <span class="nav-text">什么是服务限流限频？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限频的-Key-设计"><span class="nav-number">2.</span> <span class="nav-text">限频的 Key 设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限频实现的几种技术"><span class="nav-number">3.</span> <span class="nav-text">限频实现的几种技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏桶-Leaky-Bucket-令牌桶-Token-Bucket-是否值得区分"><span class="nav-number">4.</span> <span class="nav-text">漏桶(Leaky Bucket)/令牌桶(Token Bucket)是否值得区分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真实的流量"><span class="nav-number">4.1.</span> <span class="nav-text">真实的流量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Token-Bucket"><span class="nav-number">4.2.</span> <span class="nav-text">Token Bucket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leaky-token是否值得区分"><span class="nav-number">4.3.</span> <span class="nav-text">leaky/token是否值得区分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wikipedia的解释"><span class="nav-number">4.4.</span> <span class="nav-text">wikipedia的解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进一步理解限频"><span class="nav-number">4.5.</span> <span class="nav-text">进一步理解限频</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控频"><span class="nav-number">5.</span> <span class="nav-text">控频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">6.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限频限流注意事项"><span class="nav-number">7.</span> <span class="nav-text">限频限流注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">7.1.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thomas Lau</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>

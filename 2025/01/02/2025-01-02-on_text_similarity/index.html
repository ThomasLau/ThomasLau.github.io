<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>如何做好网文段落匹配 | 编程之海</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="网文如何段落123为什么最长公共子序列+TF-IDF是最有效方案为什么大部分人可能用错了SimhashAnsj分词工具介绍 笔者在一家阅读类App公司日常工作内容是UGC相关，包括章节段落评论部分，有一个场景是：作家新书发布章节后，用户在阅读时评论，比如划定一个段落评论，过了一段时间，作者发现文章里有错别字需要修改，或者希望删除&#x2F;合并一些段落，甚至调整段落位置。如何将改动前后的段落匹配，">
<meta property="og:type" content="article">
<meta property="og:title" content="如何做好网文段落匹配">
<meta property="og:url" content="http://thomaslau.github.io/2025/01/02/2025-01-02-on_text_similarity/index.html">
<meta property="og:site_name" content="编程之海">
<meta property="og:description" content="网文如何段落123为什么最长公共子序列+TF-IDF是最有效方案为什么大部分人可能用错了SimhashAnsj分词工具介绍 笔者在一家阅读类App公司日常工作内容是UGC相关，包括章节段落评论部分，有一个场景是：作家新书发布章节后，用户在阅读时评论，比如划定一个段落评论，过了一段时间，作者发现文章里有错别字需要修改，或者希望删除&#x2F;合并一些段落，甚至调整段落位置。如何将改动前后的段落匹配，">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-01-02T14:12:10.000Z">
<meta property="article:modified_time" content="2025-03-23T16:59:10.681Z">
<meta property="article:author" content="Thomas Lau">
<meta property="article:tag" content="TextSimilarity">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="编程之海" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">编程之海</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://thomaslau.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2025-01-02-on_text_similarity" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/02/2025-01-02-on_text_similarity/" class="article-date">
  <time class="dt-published" datetime="2025-01-02T14:12:10.000Z" itemprop="datePublished">2025-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      如何做好网文段落匹配
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网文如何段落"><a href="#网文如何段落" class="headerlink" title="网文如何段落"></a>网文如何段落</h2><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么最长公共子序列+TF-IDF是最有效方案</span><br><span class="line">为什么大部分人可能用错了Simhash</span><br><span class="line">Ansj分词工具介绍</span><br></pre></td></tr></table></figure></blockquote>
<p>笔者在一家阅读类App公司日常工作内容是UGC相关，包括章节段落评论部分，有一个场景是：<br>作家新书发布章节后，用户在阅读时评论，比如划定一个段落评论，过了一段时间，作者发现文章里有错别字需要修改，或者希望删除&#x2F;合并一些段落，甚至调整段落位置。如何将改动前后的段落匹配，使之前的评论重新关联到新段落，是一个不小的问题。<br>不过这类短文本匹配不是本人主业，这里讨论难免不足，主要还是介绍一种低成本有效的匹配方案，以及需要考虑的问题点。本文写于2021年，最近我重新编辑修改了下，因为出现了DeepSeek，使用后发现有一些场景可以很好的解决，或许依赖词库，效果不如本文介绍方法，如果有矛盾地方请忽略</p>
<h2 id="我们先来看两个问题："><a href="#我们先来看两个问题：" class="headerlink" title="我们先来看两个问题："></a>我们先来看两个问题：</h2><h3 id="为什么不使用唯一ID标识段落"><a href="#为什么不使用唯一ID标识段落" class="headerlink" title="为什么不使用唯一ID标识段落"></a>为什么不使用唯一ID标识段落</h3><p>历史业务，增加唯一段落标识对内容部门业务的侵入性较大，其次关键的是<strong>唯一段落id的标识解决不了问题</strong>：</p>
<ul>
<li>对于内容无改动的或简单合并，或者仅仅调整段落位置，唯一段落标识的确方便，不需要作任何匹配或直接修改映射</li>
<li>但如果是段落拆分，这就要考虑归属哪一段</li>
<li>内容修改，改动必然产生新的唯一段标识，还是需要比较文本或语义相似度才能匹配</li>
</ul>
<span id="more"></span>
<h3 id="为什么不用Diff算法"><a href="#为什么不用Diff算法" class="headerlink" title="为什么不用Diff算法"></a>为什么不用Diff算法</h3><p>用diff算法比较文本，似乎令人感觉高大上，比如通过Diff比较算法得到改动所涉及的操作步骤（比如插入、删除、修改），那是否就可以匹配？遗憾的是不能，因为我们的场景和协作编辑文本不同。<br>编辑文本涉及更深层次的探讨，比如CRDT协同算法，而这些算法其实主要目的是：<strong>diff和patch，即通过patch使得文本一致</strong><br>不少开源工具就基于Myers-Diff或者Pationce-Diff或Bentley-McIlroy、Paul Heckel等各类差分算法，当然还有想GumTree这类树状差异分析。像*nix diff命令算法就是Myers差分算法，而Git的Diff算法也支持：Myers、Minimal、Patience、Histogram，还有近年一些流行前端框架也使用了Diff算法处理元素变更，可能和Myers大同小异，区别可能在支持的操作和路径长短不同，diff算法介绍不是本文内容，但他们其实都不适合作为网文段落修改重新比较的算法：</p>
<ul>
<li>首先Diff算法不支持语义层面的匹配，而我们希望作者修改段落内容时，支持一定的语义匹配，或者简单说，希望标点符号的修改，不影响匹配。</li>
<li>其次，即便Diff算法满足上面语义匹配，解析diff结果本身工作量不少，像myers，同样需要处理插入、删除、修改，其面临的问题其实和唯一段标识同样多，对于变更依旧需要比较，而解析diff工作量实在不必要，而且对于修改或交换段，Myers算法有时可能是删除大段再插入(Myers删除优于插入)。</li>
<li>最后，通用性考虑。虽然Diff算法高效，但文本比较&#x2F;匹配需要的是准确和尽可能多匹配上，文本比较就更适合、更通用，比如像epub等格式小说接入几乎可以直接复用，而如果支持插图，如果使用差分diff算法，那么就会不可避免的掺杂一些格式代码，这加大了难度。</li>
</ul>
<h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><p>我最终选择的方案是LCS+TF-IDF余弦相似度两种方案结合起来，个人是下来效果不错，至于为什么不采用ED、Simhash海明距离等，下文也做了简单分析。</p>
<p>先看几类文本匹配场景，文本主要节选自《西游记》或个人杜撰（版权问题），但都是我做匹配中遇到的几个主要问题。代码各位可自行使用，或参考<a target="_blank" rel="noopener" href="https://github.com/ThomasLau/blogcode">blogcode</a>这里全部。其次假设至少80%内容相似度的才认为段可以匹配。<br>其他场景，比如段合并，或者段删除了一部分等，如果使用最长公共字串算法，其实等价拆分场景。但也存在合并段且同时某段修改文字较多，导致前后比自己相似度也达不到80%的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文本txt1， C1-C9，D1-D10表示段落号</span></span><br><span class="line">put(<span class="string">&quot;C1&quot;</span>, <span class="string">&quot;菩提老祖想了想，赐给他“孙悟空”一名。猴王非常喜欢这个名字，高兴地说：“好好好，以后我就叫孙悟空了&quot;</span>); <span class="comment">// same</span></span><br><span class="line">put(<span class="string">&quot;C2&quot;</span>, <span class="string">&quot;见到菩提老祖，美猴王跪在他跟前说：“师父，弟子有礼了！”菩提老祖说：“先别急着拜师，把你的来历一一告诉我吧。&quot;</span>); <span class="comment">// 编辑距离不同</span></span><br><span class="line">put(<span class="string">&quot;C3&quot;</span>, <span class="string">&quot;孙悟空每天和弟子们待在一起，打扫庭院，养花修树，挑水捡柴，学经论道，不知不觉过去了七年时间。一天，菩提老祖对孙悟空说：“‘道’字门中有三百六十旁门，只要悉心学习都可以学成正果，不知道你想学哪一门呢？”&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C4&quot;</span>, <span class="string">&quot;拜师后，孙悟空跟孙菩提学习打扫,看起来不得不说学习一门正果更加勤奋了,蚂蝗,还跟网友学习网游学习虚拟网络世界&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C5&quot;</span>, <span class="string">&quot;赵敏说道，是成昆把张无忌打了一顿&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C6&quot;</span>, <span class="string">&quot;贾基听了非常高兴，不禁念诗一首:『富士见之女，于西行妖满开之时，即幽明境分开之时，魂兮魄兮，归于白玉楼，尽归尘土兮&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C7&quot;</span>, <span class="string">&quot;普京与克林顿,没有参与进来，因为锦苑中学司马迁和孙权不再来玩，你说是也不是宋江去了松江府还没来得及说一首&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C8&quot;</span>, <span class="string">&quot;非UGC，仅用于goodread文插图的点赞功能,subtype=1&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;C9&quot;</span>, <span class="string">&quot;起点孙悟空和刘邦都不知所措不以为然孙权竟会干出这种事情来，说什么都不愿意&quot;</span>);</span><br><span class="line"><span class="comment">// 文本txt2</span></span><br><span class="line">put(<span class="string">&quot;D1&quot;</span>, <span class="string">&quot;菩提老祖想了想，赐给他“孙悟空”一名。猴王非常喜欢这个名字，高兴地说：“好好好，以后我就叫孙悟空了！”&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D2&quot;</span>, <span class="string">&quot;见到菩提老祖，美猴王跪在他跟前说：“师父，弟子有礼了！”菩提老祖说：“把你的来历告诉我吧，先别急着拜师，&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D3&quot;</span>, <span class="string">&quot;孙悟空每天和弟子们待在一起，打扫庭院，养花修树，挑水捡柴，学经论道，不知不觉过去了七年时间。一天，菩提老祖对孙悟空说：&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D4&quot;</span>, <span class="string">&quot;“‘道’字门中有三百六十旁门，只要悉心学习都可以学成正果，不知道你想学哪一门呢？”&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D5&quot;</span>, <span class="string">&quot;美猴王拜了师傅孙菩提以后，必须说看起来更加勤奋学习正果一门了,蚂蝗,还跟网友自学虚拟网络世界自学网游&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D6&quot;</span>, <span class="string">&quot;是张无忌把成昆打了一顿，赵敏说道&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D7&quot;</span>, <span class="string">&quot;接下来，贾基直接念了一首诗:『富士见之女，于西行妖满开之时，即幽明境分开之时，为其魂魄，安息于白玉楼中，将西行妖之花封印作&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D8&quot;</span>, <span class="string">&quot;普京与克林顿,没有达成，因为普通物理不允许司马迁和孙权不是一路人，听了松江府的宋江说来说去不明白是还是不是&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D9&quot;</span>, <span class="string">&quot;非UGC，仅用于betterread文插图的点赞功能,subtype=1&quot;</span>);</span><br><span class="line">put(<span class="string">&quot;D10&quot;</span>, <span class="string">&quot;起点孙悟空和刘邦都去了云南打猎，回来时候路过牛家村，看到满天繁星，想起了孙权&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>匹配的本质是找到相似性，而计算机运算离不开数字化数值化，所以文本相似性需要数字化的表示，可以是基于字符的编码、可以基于最简单元素集合的相似性、可以基于句子的特征向量化、可以基于词的向量化，甚至把句子用矩阵表示，因此产生了诸如词袋模型、TF-IDF、LSA、LDA、N-gram、主题模型、词向量（word2vec等）、ESim、BERT等语言模型。大师Ullman的《大数据-互联网大规模数据挖掘与分布式处理》 书中列举各种距离算法，欧几里得、Jacard、海明(汉明)距离、莱文斯基距离、余弦距离、超平面等。我这里从实用角度看，近考虑并比较了基于字符的编辑距离、最长公共子串、基于特征向量的TF-IDF+余弦距离、SimHash+海明距离等实现分别对比下效果，涉及到分词组件Ansj、HanLp、少量BERT语义等部分知识</p>
<h3 id="编辑距离（Edit-Distance）"><a href="#编辑距离（Edit-Distance）" class="headerlink" title="编辑距离（Edit Distance）"></a>编辑距离（Edit Distance）</h3><p>WikiPedia：编辑距离，即Edit Distance，是衡量两个字符串相似度的方法。它表示从一个字符串转换为另一个字符串所需的最少单字符编辑操作次数，这些操作包括插入、删除或替换，编辑距离也叫Levenshtein距离。<br>学计算机的可能大多第一反应是这个算法，下面代码levenshteinSimCalc方法所示，直接采用Apache Common Text的库实现，当然时间&#x2F;空间复杂度m*n等不是本文讨论重点。<br>上面 C1行和D1行，相差末尾两个标点符号，所以得到的Levenshtein相似度0.96是相似度的，但可惜的是匹配C2和D2以及C3和D3就有问题了，因为C2和D2基本是部分顺序不同，C3则拆分为D3和D4，用编辑距离显然匹配不到，不满足需求</p>
<h3 id="最长公共子串（LCS）"><a href="#最长公共子串（LCS）" class="headerlink" title="最长公共子串（LCS）"></a>最长公共子串（LCS）</h3><p>最长公共子串（Longest Common Substring），不过这里严格来说是这里使用的是最长公共子序列（Longest Common Subsequence LCS）是从给定的两个序列中取出尽可能多的公共子元素，按照它们在原序列排列的先后次序排列得到（即寻找公共子序列），子序列不必是连续的，和编辑距离一样都属于动态规划算法<br>C2&#x2F;D2匹配，用Jarcard相似度可以解决，但对于中文需要分词，否则如果默认单字分割，不仅失去内容语义，更可能因大量单字重复匹配失效。<br><strong>LCS就可以很好的兼容C2和D2以及C3和D3的匹配，实际上对于网文段落匹配来说，LCS适合大多数修改类的匹配工作</strong>，因为章节编辑变更常见的是字、部分用词、合并拆分段落。可以看到 下文lcsSimCalc方法，将C2&#x2F;D2，C3&#x2F;D3都匹配上了，相比Levenshtein则认为不匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 距离编辑算法 的 最大相似度</span><br><span class="line">lev:C1 -&gt; D1 similarity: 0.9608</span><br><span class="line">lev:C2 -&gt; D2 similarity: 0.6852</span><br><span class="line">lev:C3 -&gt; D3 similarity: 0.5900</span><br><span class="line"># LCS算法 的 最大相似度</span><br><span class="line">lcs:C1 -&gt; D1 similarity: 1.0000</span><br><span class="line">lcs:C2 -&gt; D2 similarity: 0.8462</span><br><span class="line">lcs:C3 -&gt; D3 similarity: 1.0000</span><br></pre></td></tr></table></figure>

<h2 id="基于分词"><a href="#基于分词" class="headerlink" title="基于分词"></a>基于分词</h2><p>遗憾的是，编辑距离或者LCS方法对于C4-C7的匹配无能为力，得到最大相似度都在0.6以下，我希望匹配方案带有一点语义识别能力，可以将剩下几类场景明确是否匹配上。所以，想到了分词后+Jarcard相似度或特征向量可以实现。<br>比如最简单的词袋模型，BOW全名叫Bag of words，我们分词后再用Jarcard相似度，C5完全可以匹配，甚至C4、C6也能匹配上对应行！即，假设我们使用Lucene的默认一个汉字一个汉字分词StandardAnalyzer 是可以得到跟D5有0.8以上相似度，但是如果同时减少C4&#x2F;D5的末尾8个字，相似度就不足0.8了， 另外BOW并不能标识出一个段中重点的部分，比如C4和D5都有“蚂蝗” 这个极少见词汇，希望在匹配时候可以为此加分，为此一个改进是TF-IDF（term frequency–inverse document frequency），即词频-逆向文件频率，就可以支持，另一个是分词+SimHash，虽然都和BOW一样只关注词之间的关系， TF-IDF是bow一种，我们且简称为TF-IDF模型<br>上面描述的是词和文本关系，那么如果想基于词于词之间的语义关系或词句语义&#x2F;语法等关系如何实现呢，这就是另一种词向量技术，Word Embedding，将词映射到固定维度的实数向量空间中，目前看主要发展出基于统计学和基于上下文两个方向，比如机器学习入门就会提到的2013年诞生的Word2Vec（CBOW和Skip-Gram）、SoftMax、Glove、FastText属于前者， 现在流行的BERT和GPT主要基于上下文，这些并非笔者特长，暂且不深入介绍。</p>
<h4 id="是否需要语义"><a href="#是否需要语义" class="headerlink" title="是否需要语义"></a>是否需要语义</h4><p>所以，这里介绍点其他的，比如提两个注意点</p>
<ul>
<li><strong>匹配更多的判断依据是”长得像“</strong><br>上文的C5和D6就会被语义模型认为不匹配的，<strong>因为主语和宾语颠倒了</strong>，或许如果后续接入语义相似，我们可以通过规则或者调参改变，但是否存在其他情况呢，比如否定之否定或者只是改为反问语气，即便假设人类语言文法是规范的，也存在作家写错字情况，还有更多考虑，比如作家第一遍某段写的是“xxx，我喜欢你”，但后来想想改成“xxx，我不喜欢你”，甚至“xxx，我讨厌你”，语义上都是不相似的，但我们知道有时候女孩子的不喜欢可能是喜欢，讨厌也是喜欢。。。总之调参无尽头，<strong>但我们的场景，其实期望的是只要长得像就是相似的</strong>，即便是出现上文主宾颠倒、替换，换句话说大多时候我们匹配的不需要word vector&#x2F;embedding或者sentence vector&#x2F;embedding的东西，甚至关注“每个单词都是由其周围的单词所定义”对于比较变化意义不大。总之，和语义匹配最大不同是 <strong>语义不相似的段可能是被认为匹配的</strong>，比如“我明天就出发去北京”和“我后天就出发去北京”，甚至是去“上海”，可能都希望匹配上。</li>
<li><strong>匹配是从本章节各个段落里找到长得最像的</strong><br>还是上文C5和D6，我上面说他们是相似的，前提是这个章节变更后没有相似的，如果文本2还有一段 “D9 赵敏说道，是成昆把张无忌打了一顿”，即如果这个章节本来同时就存在这两句类似的话，比如是两个角色对话，一个观点是张无忌打成昆一个是 成昆打张无忌，那显然C5匹配的应该是D9而非D6。即这里不仅仅是相似度，还是匹配的问题，举个例子：<br>“我的衣服有一些旧了，我想去商场买一件新衣服”<br>”我的裤子有一些破洞了，我也想去商场买一件新裤子“<br><strong>通过大模型或者词向量分析，都可以得到两句有高度相似的结论，但是这两句可能会同时出现在一段二人对话中，不应该认为是匹配的</strong></li>
</ul>
<h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h3><p>基于分词可以解决上面无法匹配C5和D6的问题，如果你也认为词义即语义，那分析词的相似性就是有意义的<br><strong>TF-IDF模型：</strong> 将文本中的每个词的出现频率和文本中其他文档中的出现频率进行权重，并将这些权重组合在一起形成一个向量。夹角就是他们的相似度，这自18世纪就被使用<br>不论上面词袋模型还是TF-IDF，都是将文本中的每个词视为一个独立的特征，并组合一起为一个高维向量，TF-IDF方法是一种改进的词袋模型（Bag-of-Words）方法，通过结合词频（Term Frequency，TF）和逆文档频率（Inverse Document Frequency，IDF）来评估词汇在文档中的重要性。<br>笔者过早地看过吴军博士搜索原理系列的TF-IDF计算余弦相似度方法，所以一直是拿来主义，没有思考过<strong>为什么TF-IDF+余弦夹角就可以计算出相似度？以及为什么公式需要用log函数</strong>？如果你认为只是简单的希望降低权重，那确实错过了“why”，错过理解一些底层的知识。我没有找到使用词频的理论依据，但想来这更可能是一个工程实践结果，因为我们完全可以根据词频构造一篇文章，但是实际结果狗匹配不通。<br>这种构造同样也适用于下文的SimHash算法， 但SimHash除了可以通过调整顺序构造高度相似文本，还有其他问题，我下文会再指出。<br>所以，我认为这里前提需要<strong>假设文本特征可以通过关键词语反应出来</strong>，其次就像可计算理论所追求的，语言可以是一种模型，至少像乔姆斯基体系建立起来的各型文法一样。<br><strong>当然需要一些限制条件才可以量化和计算，否则就会陷入“狗不是猫的同义词”，但是“猫和狗是相似的”这种纠结里，比如可以像分布式假设所定义的“如果两个词语在不同的文本中出现在相似的上下文中，那么它们的语义应该是相似的”</strong><br><strong>TF-IDF 就是建立在“对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语” 假设，这个假设也有不足，因为人类自然语言有时候并不是频率大的词就无用，其次，单词的先后顺序(位置)也很重要</strong>，这些是后话，重要的是基于这个假设能否推导出什么。<br>TF-IDF向量空间是一个把文本文件表示为一系列特征向量的代数模型，TF-IDF和向量空间都是实践先于理论，布尔模型、向量模型等各种经典的信息检索模型都是是早期检索软件系统引入的概念，<strong>TF-IDF则是发表后才有信息学的解释</strong>，《数学之美》中有信息熵和词频、逆文本频率等论述，我就不重复了，<strong>需要说明的是TF-IDF并不是信息熵推导的一个结果，但信息熵的可以解释其合理性</strong>，比如相对熵、交叉熵这些重要的概念，因为这里理解的相关性(或者说重要性)其实是建立在文档里的这个词对本次查询能带来多少信息，但我们不需要使用搜索功能，TF-IDF在搜索子串上的不足也就不存在。主要使用TF-IDF进行相似度比较。<br>进一步可以参考Ullman的《大数据-互联网大规模数据挖掘与分布式处理》，相似性LSH函数族这章。<br>这里可以看到，似乎只要能够向量化，就可以考虑使用余弦相似度，比如 地理空间相似度，社区相似度等，这其实很符合人类给万物分类的思维，比如生物学上的分类，就会列举出多个特征，只不过是叫LDA或者SVM。<br>不过单词或者说特征，本质上是一种局部信息，<strong>需要记住的是局部基本相似未必全局相似</strong>，除了上文提到的单词位置&#x2F;顺序一类例子，还有一种是语义上的，比如例子：”你们觉得扮演赵敏的人好看吗 &#x2F; 你们觉得扮演周芷若的人好看吗“，或者“一个十亿维的向量&#x2F;十亿个一维的向量”，不同的权重甚至不同的分词结果，基于TF-IDF可以得出这两句相似也可能不相似，但语义上基本会认为是不相似的（至少后者如此）。因为这两类句子主语或者重点词语描述的不是一个对象。<br><strong>但考虑到网文匹配场景，这两种结果都是有可能的</strong></p>
<ul>
<li>比如作者就是把赵敏写错为周芷若后续修改时，我们认为两段应该匹配</li>
<li>但也有可能这个章节中同时存在这两段，这个时候就不应该匹配上</li>
</ul>
<p>目前我们没有解决这类场景，只是靠LCS全局<strong>最</strong>匹配可以避免，后续可能需要借助具备语义匹配的模型结合上下文匹配<br><strong>最后</strong> 基于TF-IDF并不是唯一余弦相似度方案，改进的还有BM25权重、LDA主题模型、词向量模型等的余弦相似度，我们场景基于一个章节，<strong>使用BM25大材小用，不过代码里我还是写了一个BM25算法的实现作为参考</strong>。TF-IDF方案则分为文本预处理、分词(和词性标注）、词频统计与向量转换、余弦计算三个步骤：</p>
<h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>中文分词（chinese word segment，cws）常见的<a target="_blank" rel="noopener" href="https://lujiaying.github.io/posts/2018/01/Chinese-word-segmentation/">几个问题是</a>：歧义（真歧义、组合歧义、交集歧义）、未登录词（新词）、分词方案不唯一（上海虹桥机场）。网文段落匹配其实不需要考虑歧义一词多义类，只要文字同就认为相似， 未登录词是需要重点考虑的。<br>因为歧义和分词方法不唯一，所以完美分词是难的，比如基于词典“普京和川普通话”，我们词典很可能就有普京&#x2F;普京和川&#x2F;川普，当然这里不考虑作家把“四”写成了“和”， 其次即便达到人类的语言感知级别，<strong>完美分词也是不存在的，比如有名的“下雨天留客天留人不留”，本身就包含两种分词结果</strong>，而且对应两种截然相反的含义。不过这里还好只要相似，不需要智能的判断语义相似与否。<br>词典匹配的分词方法可以分为：正向和逆向；根据词的匹配策略可以分为：最长词优先和最短词优先。具体地，常见的基于词典匹配的分词方法：<br>完全切分匹配、正向最长匹配、逆向最长匹配、正向最小匹配、逆向最小匹配、双向最长匹配，产生了HMM（viterbi decode）、MEMM（viterbi decode）、Linear + CRF、MLP + softmax、深度模型+ CRF等分词算法，具体可以参考宗成庆老师的《自然语言理解》<br><strong>IKanalyzer、Ansj_seg、jcseg、HanLP</strong> 是当前比较流行且实用的Java分词组件，具体可以参考官网，这里总结下笔者使用感受：</p>
<ul>
<li><strong>IKanalyzer</strong><br>基于“正向迭代最细粒度切分算法”，笔者自接触Lucene到ES用的最多中文分词组件，使用和配置都比较方便，代码简单。尤其适合搜索“索引要做到最细颗粒度切分尽可能多的词，检索要做到最大颗粒切分（当然也有最多）”场景，但分词能力受限于字典，适合用于内容搜索，或相对文字规范用词正确的内容分词，对于现代互联网用词日渐随意和口语化不适合，对于用户评论以及表情包，尤其是我们面对的场景，网文里作家创造各种奇奇怪怪的人物名字、地理名字、社会机关名字等新名词必然频出。</li>
<li><strong>Ansj_seg</strong><br>HanLP之前，笔者用的第二多的是Ansj_seg，功能非常丰富，源于中科院的 ictclas 中文分词算法，支持基于字典的DicAnalysis和CRF模型NlpAnalysis分词，前者适合搜索建立索引，NlpAnalysis支持发现新词，非常适合我们的场景。<br>举个例子：“美猴王跟着孙菩提学习了三百六十天”，因为IK词库有美猴王没有孙菩提，所以分词结果是“美猴王&#x2F;跟着&#x2F;孙&#x2F;菩提&#x2F;学习&#x2F;了&#x2F;三百&#x2F;六十&#x2F;天”，Ansj_seg虽然没有收录美猴王和孙菩提，但是根据core词典里“跟”作为介词可能性更大以及BEMS标注，认为“美猴王”切分的可能性较大，所以正确的识别出来“美猴王&#x2F;跟着&#x2F;孙菩提&#x2F;学习&#x2F;了&#x2F;三百六十&#x2F;天”，可以说非常适合了。<br>但NlpAnalysis似乎不适合搜索场景使用，尤其是NlpAnalysis和ictclas 一样支持自定义词库有限，但优先还是使用自带core字典收录词（笔者经验教训是搜索时宁用IKanalyzer不用Ansj_seg）如果增加自定义，需要自己训练模型</li>
<li><strong>FudanNLP</strong>   看了下源码，可能不适合正是环境中大规模的去使用。</li>
<li><strong>HanLP</strong>  可能是目前功能最丰富的中文自然语言处理工具包，内置如CRF分词、HMM分词等，具体可以参考官网介绍。</li>
</ul>
<p>下面代码里我分别用Ansj_seg和HanLP分词组件实现不同算法作为对比，二者各自的NLP分词器都具备一定的发现新词能力，代码较多，我上传到github上了，<a target="_blank" rel="noopener" href="https://github.com/ThomasLau/blogcode">移步这里</a><br>上面代码除ED(LD)、LCS、基于Ansj的TF-IDF向量实现、HanLP+Simhash的实现，后者是DeepSeek给的一个词向量方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;----main-----&quot;</span>);</span><br><span class="line">    TFIDFByLucene.init(<span class="string">&quot;ansj&quot;</span>, <span class="string">&quot;nlp_ansj&quot;</span>);</span><br><span class="line">    lcsSimCalc(text1, text2);</span><br><span class="line">    levenshteinSimCalc(text1, text2);</span><br><span class="line">    tfidfSimCalc(text1, text2);</span><br><span class="line">    hanlpSimCalc(text1, text2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dloopBestMatchFunc</span><span class="params">(String tag, Map&lt;String, String&gt; text1, Map&lt;String, String&gt; text2,</span></span><br><span class="line"><span class="params">        BiFunction&lt;String, String, Double&gt; func)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (String key1 : text1.keySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">bestScore</span> <span class="operator">=</span> -<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key2 : text2.keySet()) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> func.apply(text1.get(key1), text2.get(key2));</span><br><span class="line">            <span class="keyword">if</span> (score &gt; bestScore) &#123;</span><br><span class="line">                bestScore = score;</span><br><span class="line">                bestMatch = key2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s:%s -&gt; %s similarity: %.4f&quot;</span>, tag, key1, bestMatch, bestScore));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanlpSimCalc</span><span class="params">(Map&lt;String, String&gt; text1, Map&lt;String, String&gt; text2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    dloopBestMatchFunc(<span class="string">&quot;hanlp&quot;</span>, text1, text2, (line1, line2) -&gt; &#123;</span><br><span class="line">        <span class="type">SimHash</span> <span class="variable">hs1</span> <span class="operator">=</span> HanLpSimilarity.simHash(line1);</span><br><span class="line">        <span class="type">SimHash</span> <span class="variable">hs2</span> <span class="operator">=</span> HanLpSimilarity.simHash(line2);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> hs1.getSemblance(hs2);</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lcsSimCalc</span><span class="params">(Map&lt;String, String&gt; text1, Map&lt;String, String&gt; text2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    dloopBestMatchFunc(<span class="string">&quot;lcs&quot;</span>, text1, text2, (line1, line2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> lcsSimilarity(line1, line2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levenshteinSimCalc</span><span class="params">(Map&lt;String, String&gt; text1, Map&lt;String, String&gt; text2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    dloopBestMatchFunc(<span class="string">&quot;lev&quot;</span>, text1, text2, (line1, line2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> levenshteinSimilarity(line1, line2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tfidfSimCalc</span><span class="params">(Map&lt;String, String&gt; text1, Map&lt;String, String&gt; text2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Map&lt;String, Map&lt;WordInfo, Double&gt;&gt; tfIdf1 = TFIDF.create(text1, ANALYZER, WRDFILTER);</span><br><span class="line">    Map&lt;String, Map&lt;WordInfo, Double&gt;&gt; tfIdf2 = TFIDF.create(text2, ANALYZER, WRDFILTER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefx</span> <span class="operator">=</span> <span class="string">&quot;TFIDF&quot;</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; weights = TFIDFByLucene.WeightsMap;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != weights &amp;&amp; !weights.isEmpty()) &#123;</span><br><span class="line">        tfIdf1.values().forEach(ent -&gt; reWeight(ent, weights));</span><br><span class="line">        tfIdf2.values().forEach(ent -&gt; reWeight(ent, weights));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (String key1 : tfIdf1.keySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">bestScore</span> <span class="operator">=</span> -<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key2 : tfIdf2.keySet()) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> Cosine.cosineSimilarity(tfIdf1.get(key1), tfIdf2.get(key2));</span><br><span class="line">            <span class="keyword">if</span> (score &gt; bestScore) &#123;</span><br><span class="line">                bestScore = score;</span><br><span class="line">                bestMatch = key2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s: %s -&gt; %s with similarity: %.4f&quot;</span>, prefx, key1, bestMatch, bestScore));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reWeight</span><span class="params">(Map&lt;WordInfo, Double&gt; words, Map&lt;String, Integer&gt; weights)</span> &#123;</span><br><span class="line">    words.entrySet().forEach(ent -&gt; &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">weit</span> <span class="operator">=</span> weights.get(ent.getKey().getType());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != weit) &#123;</span><br><span class="line">            ent.setValue(ent.getValue() * weit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> WordAnalyzer&lt;WordInfo&gt; ANALYZER = <span class="keyword">new</span> <span class="title class_">WordAnalyzer</span>&lt;WordInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;WordInfo&gt; <span class="title function_">split</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TFIDFByLucene.splitWords(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Predicate&lt;WordInfo&gt; WRDFILTER = <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;WordInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(WordInfo wd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !TFIDFByLucene.EXCLUDE_TYPE.contains(wd.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">levenshteinSimilarity</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(s1) || StringUtils.isEmpty(s2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> apacheLevenshtein(s1, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">lcsSimilarity</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lcsth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongestCommonSubsequence</span>().apply(s1, s2);</span><br><span class="line">    <span class="keyword">if</span> (lcsth &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lcsth * <span class="number">1d</span> / Math.min(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcsth * <span class="number">1d</span> / Math.max(s1.length(), s2.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">apacheLevenshtein</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0d</span> - LevenshteinDistance.getDefaultInstance().apply(s1, s2) * <span class="number">1.0d</span> / Math.max(s1.length(), s2.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 上面 C4&#x2F;D5，如果把“美猴王”改为“孙悟空”，我用一些语义相似度供应商有的判定 90.75%相似度，也有97%，后者我认为略高了，但显然都比只是简单的使用 ED、Levenstein、LDA&#x2F;TF-IDF分析都要准确<br>但如果我把D5中的“孙悟空”改为“美猴王”之后，相似度竟然从90.75%变为 4.75%，这显然不是一个合适的算法。因为看过《西游记》都知道美猴王就是孙悟空另一种称呼，”自学”和“学习”也算同义词，而且即便不考虑同义词，相似度降到5%是不稳定的。我们期望的是这里不会仅仅因改了人物别名就变得匹配不上<br>或许使用这类自然语言理解工具需要更多的训练和理解同义词，当然也可以使用同义词<a target="_blank" rel="noopener" href="https://github.com/chatopera/Synonyms">发现工具计算词向量得到同义词</a>， 总之<strong>首先需要分词组件Ansj和Hanlp支持同义词</strong>，比如这里“美猴王”这个词条都不在二者同义词库，所以需要加入进去（hanlp：data&#x2F;dictionary&#x2F;synonym&#x2F;CoreSynonym.txt， ansj：&#x2F;library&#x2F;synonyms.dic），<strong>其次配置停止词</strong>，有些比如“了”之类的词过滤掉，可以配置各自的stopword，Ansj默认stop word较少，可以酌情增减，不过这不是本文重点，<strong>不过需要提醒的是，Ansj的默认配置，会把动词过滤掉，需要从stop.dic删除”v   nature” 这行配置。HanLP本身具备同义词库，但是过于丰富以至于可能在比较相似性时失真</strong>。<br>总的来说是：</p>
<ul>
<li>HanLp的同义词，为了比较相似度，需要我们在分词后，换成同义词列表中第一个词，保持 一致</li>
<li>Ansj的同义词， 本文逆文档率是通过Lucene实现，所以开始选择Ansj的Lucene插件，但是后来发现，Ansj近义词插件实际在创建索引时会取出全部匹配的同义词写入到索引，这导致IDF失真，所以需要做些改动，如下面代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">org.ansj.lucene.util.AnsjTokenizer</span><br><span class="line"><span class="title function_">if</span> <span class="params">(synonyms != <span class="literal">null</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SynonymsRecgnition sr : synonyms) &#123;</span><br><span class="line"><span class="comment">//                parse.recognition(sr);</span></span><br><span class="line">        <span class="keyword">for</span> (Term term : terms) &#123;</span><br><span class="line">            SmartForest&lt;List&lt;String&gt;&gt; branch = SynonymsLibrary.get().getBranch(term.getName());</span><br><span class="line">            <span class="keyword">if</span> (branch != <span class="literal">null</span> &amp;&amp; branch.getStatus() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                List&lt;String&gt; syns = branch.getParam();</span><br><span class="line">                <span class="keyword">if</span> (syns != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">synName</span> <span class="operator">=</span> syns.get(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// term.setSynonyms(syns);</span></span><br><span class="line">                    term.setName(synName);</span><br><span class="line">                    term.setRealName(synName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而HanLP则是在解析词列表时候，再过一遍同义词词典，如果是名词，则取出同义词第一个</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;n&quot;</span>.equals(nature)) &#123;</span><br><span class="line">    <span class="type">SynonymItem</span> <span class="variable">synciters</span> <span class="operator">=</span> CoreSynonymDictionary.get(word);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != synciters &amp;&amp; <span class="literal">null</span> !=synciters.synonymList &amp;&amp; synciters.synonymList.size() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">        word = synciters.synonymList.get(<span class="number">0</span>).realWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即需要把AnsjTokenizer parse方法parse.recognition改成替换同义词列表第一个。同样的HanLp可以在分词后再逐个通过CoreSynonymDictionary替换（也可以这里限制仅为名词或成语时同义词生效）<br>总之设置同义词之后，可以看到相似度有不少提升，<strong>但这么做不是没有副作用的，因为其同义词可能存在文本中，影响TF-IDF值</strong>。上面列举的C1&#x2F;C2之外大部分是例外情况，真实匹配遇到大部分还是可以通过LCS+TF-IDF匹配上的，这里只是分析下几个低于0.8相似度的原因。<br>比如上面C8和D9通过simhash&#x2F;TFIDF都可以得到接近0.9的相似度，效果不错，不过TFIDF即使用Ansj分词，并不稳定，比如我把“goodread”替换为“烂番茄” 得到的相似度降到0.3了，这是因为替换为“烂番茄”后，分词由”goodread&#x2F;文插图“变成了“烂番&#x2F;茄文&#x2F;插图”, 一拆为三且都是名词有二倍的权重。<br>分词不理想是因为“烂番茄”不在Ansj的词典中， NlpAnalysis使用的就是crfmodel训练数据，逐个切分字符后，同隐含马尔可夫模型类问题一样，使用Viterbi算法，从CRF模型数据逐字计算BEMS状态转移概率，计算出<br>番&#x2F;文&#x2F;图各自的tag为E，即对应结束状态，所以分词成三份。而“goodread文插图”则在CRF进行vterbi之前，goodread已经被识别为一个英文单词作为一个Element，所以“文”对应的标签是B，后续“插”无法作为E，而“图”可以，所以分成了”goodread&#x2F;文插图“:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hanlp+simhash+同义词</span><br><span class="line">  “非ugc/仅/用于/goodread文/插画/的/点赞/效用/subtype/1”</span><br><span class="line">  “非ugc/仅/用于/烂/番茄/文/插画/的/点赞/效用/subtype/1”</span><br><span class="line">Ansj_seg+tfidf</span><br><span class="line">  “非ugc/仅/用于/goodread/文插图/的/点赞/功能/subtype/1”</span><br><span class="line">  “非ugc/仅/用于/烂番/茄文/插图/的/点赞/功能/subtype/1”</span><br></pre></td></tr></table></figure>
<p>所以tfidf得到相似度较低，相比之下，HanLP+Simhash看起来较为稳定，始终只切出了“插图”，虽然结果相对较好，但是却是错误的，这里其实就可以看出其将C7与D3认为最匹配，效果最差，具体下文Simhash部分分析一下。<br>这里试了下如果给名词&#x2F;人名权重2，可以得到不错效果，大多超过0.8相似度。但其实也并不合适，比如西游记前几章或者拜师这里，每段频繁出现人名，像上面hanlp+simhash C9匹配到D1(但也和hash有关，下文提及)</p>
<h3 id="基于Lucene的TFIDF"><a href="#基于Lucene的TFIDF" class="headerlink" title="基于Lucene的TFIDF"></a>基于Lucene的TFIDF</h3><ul>
<li>如果你不了解Lucene或TFIDF，我在blogcode提供了一个纯内存的TFIDF和BM25实现，这里使用Lucene是希望ByteBuffersDirectory减少堆内存使用，因为试下来大量比较耗内存或者cpu，而耗内存导致高频GC导致cpu较高，基于Lucene试下来损耗少</li>
<li>另外一个问题是，如果章节的段非常少，比如1至n段， 也就是本次只有1至n个文本，那可能很多词会出现在至少n-1个文本中，也就意味着这些词的逆文档率为0，即cossine后可能一直是0，也即永不相似，应避免</li>
</ul>
<h3 id="TFIDF-余弦总结"><a href="#TFIDF-余弦总结" class="headerlink" title="TFIDF+余弦总结"></a>TFIDF+余弦总结</h3><ul>
<li>分词选择<br>不考虑加入到词典的话，Ansj_seg分词 “锦苑中学”&#x2F;”文插图”一定程度可以识别出来，HanLP则较大概率识别两个，虽然hanlp考虑的多，支持多种分词，但Ansj_seg训练自己的CRF模型也较为简单，我最终选择了Ansj_seg，<a target="_blank" rel="noopener" href="https://taku910.github.io/crfpp/">开源CRF++</a>训练</li>
<li>文本影响<br>TFIDF显然受段增减影响，从而影响余弦距离计算，即假设去掉相同段落，影响了idf，从而影响相似度，但删减几段对于大部分词影响微小，而hanlp+simhash不受影响</li>
<li>基于CRF，词语稍微变化或之前有错别字&#x2F;语法错误，容易直接影响分词结果</li>
<li>Simhash或TFIDF都直接受分词影响，同样一段文字分词结果不同直接影响相似度，尤其是上面使用了CRF技术(甚至大部分基于LSTM&#x2F;HMM思想)的分词</li>
<li>但发现和维护新词，确实有不小的代价</li>
<li>可以看到含有仿古文，分词困难，直接导致相似度判定分歧大，效果差，这或许是因为古汉语语法规范但是含义不规范，尤其是是一词多义，比如上面C6和D7， ”归于“这里可以理解和”安息于“同义。（但实际上，即便最先进的语义判定可能相似度较低，也应归于“匹配”）</li>
</ul>
<h2 id="Simhash"><a href="#Simhash" class="headerlink" title="Simhash"></a>Simhash</h2><p>Simhash是Charikar 在2002年提出来的，参考 《Similarity estimation techniques from rounding algorithms》，谷歌网页去重可能就是参考这里工程化地实现，笔者前面也介绍过：<a target="_blank" rel="noopener" href="https://thomaslau.xyz/2020/06/13/2020-06-13-on_hash_3/">开发常见的Hash函数(三)-Minhash_Simhash</a>，一般基于分词的Simhash过程如下，这里参考知名网站给的实现，我后面介绍下这里错误的几个地方：</p>
<ul>
<li><strong>分词，去掉停用词，确定词的权重</strong>(权重表示词对文档的重要程度，可以用词频)</li>
<li><strong>哈希，将每个词映射为向量</strong>，要求每个词映射后的向量随机分布，且不同词对应的向量不同，因此使用一般的哈希方法即可</li>
<li><strong>加权</strong>，将每个词的哈希签名h看做01串，设词的权重为w，则签名的第k位加权为h(k) &#x3D; h(k)&#x3D;&#x3D;1?w:-w</li>
<li><strong>合并</strong>，将文档中所有词的加权签名按位累加</li>
<li><strong>降维</strong>，h(k) &#x3D; h(k)&gt;0:1?0</li>
</ul>
<p>需要指出的是谷歌的Simhash判定相似度方案是未被证明过的，笔者未找到，倒是找到论文是统计Simhash计算相似度的误差分析。但不能不说的是，Simhash一定从海明距离获取许多灵感，在此之前，像余弦特征描述音乐，描述相貌匹配度，海明距离描述指纹相似性等均有大量应用。<br>但Simhash确实有理论支撑的，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%E9%80%8A-%E6%9E%97%E7%99%BB%E6%96%AF%E7%89%B9%E5%8A%B3%E6%96%AF%E5%AE%9A%E7%90%86">Johnson–Lindenstrauss引理</a>，学习机器学习应该了解这块基础理论：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Johnson–Lindenstrauss引理是一个关于降维的著名定理...这个定理告诉我们:</span><br><span class="line">一个高维空间中的点集，可以被线性地镶嵌到低维空间中，同时其空间结构只遭受比较小的形变</span><br><span class="line">约翰逊-林登斯特劳斯定理的证明，还说明了如何用随机投影法明确地求出这个变换，所用的算法只需要随机多项式时间。</span><br><span class="line">当然，降维不是免费的：</span><br><span class="line">如果要求形变很少的话，代价是被嵌入的低维空间维数不能很低；反之亦然，如果要求将点集嵌入很低维的空间，那么就不能很好地控制结构形变的程度。</span><br></pre></td></tr></table></figure>

<p>更有趣可以参考“科学空间”的几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.spaces.ac.cn/archives/8679/comment-page-1">让人惊叹的Johnson-Lindenstrauss引理：理论篇</a></li>
<li><a target="_blank" rel="noopener" href="https://kexue.fm/archives/9588">从JL引理看熵不变性Attention</a></li>
<li><a target="_blank" rel="noopener" href="https://kexue.fm/archives/7695">最小熵原理（六）：词向量的维度应该怎么选择？</a></li>
</ul>
<p>简单理解为，对于词向量而言，Simhash是一个欧氏空间向量降维的结果，尽管是有损的。<br>本文使用的HanLP+Simhash部分的代码其实是从deepseek得到的示例，看起来代码出处是这里<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1043655%EF%BC%8C">https://cloud.tencent.com/developer/article/1043655，</a> 笔者做了些调整，作为对比列出。<br>不过原代码因为考虑到需要支持128位或更多，所以使用了BigInteger实现，笔者提供了另一个基于64bit的实现:QuickSimHash， 实际测下来当使用64bit时，计算精确度表现不会差于deepseek提供的这个算法，但性能更是快了60-70倍。</p>
<h3 id="为什么Simhash词的权重不宜过高"><a href="#为什么Simhash词的权重不宜过高" class="headerlink" title="为什么Simhash词的权重不宜过高"></a>为什么Simhash词的权重不宜过高</h3><p>但Simhash变现的稳定性也是它的问题所在，即比如可以对某一类名词统一设置权重，但是不能像tf-idf一样灵活的根据词频设置权重–那么，可否修改代码，查询词频来tf或idf设置权重？<br>Simhash也可以跟VSM一样基于特征项在文档中的重要程度分配权重，一般分配分配方式比较固定，如果想反应不同的单词作为特征的不同的重要度，可以考虑动态规则（如tfidf值）。有个知名去重应用是这么做的，但TFIDF值作为参考设置权重需要注意权重相差过大，可能是有问题的，尤其是比如词频导致某一类词权重是其他一百倍，余弦方法可以很快较低影响，但对于Simhash则其他100词带来的影响可以忽略！比如64-bit的simhash时，输入词“美猴王”权重给了100，得到simhash：sim-A即我们知道simhash每次实际只是根据现有64个int正负值确定加减1翻位，<strong>也就意味着权重100导致这64个int数组值已经是+100或-100了，这意味着再输入99次任意字符，这些int数组正负不变！</strong>，即此时的simhash和sim-A海明距离依旧是0!<br><strong>举个例子更直观理解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">computeSimHashFromString</span><span class="params">(List&lt;String&gt; shingles)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v[] = <span class="keyword">new</span> <span class="title class_">int</span>[HASH_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (String shingle : shingles) &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = shingle.getBytes();</span><br><span class="line">        <span class="type">long</span> <span class="variable">longHash</span> <span class="operator">=</span> FPGenerator.std64.fp(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; HASH_SIZE; ++i) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">bitSet</span> <span class="operator">=</span> ((longHash &gt;&gt; i) &amp; <span class="number">1L</span>) == <span class="number">1L</span>;</span><br><span class="line">            v[i] += (bitSet) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">simhash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; HASH_SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            simhash |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> simhash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码里数组v就是64个平面投影，也是加减weight权重的数组，<strong>极端情况</strong>，比如下面是我使用500个连续的“he”作为输入，进行64位simhash得到结果，500,-500….这些是最后一轮时64个特征(维度)对应的数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12017435215498645308:[-500, -500, 500, 500, 500, 500, -500, -500, 500, 500, 500, 500, -500, -500, -500, -500, 500, -500, -500, -500, 500, -500, -500, -500, 500, 500, -500, 500, -500, -500, 500, -500, -500, -500, -500, 500, -500, 500, -500, 500, 500, -500, -500, -500, -500, -500, -500, 500, -500, 500, 500, -500, -500, -500, 500, 500, -500, 500, 500, -500, -500, 500, -500, 500]</span><br></pre></td></tr></table></figure>
<p><strong>最终64位的Simhash值就是根据上面大于0小于0设置1&#x2F;0值并逆序</strong>。所以不难理解，最终结果非0则必是正500或负500，<strong>这意味着什么呢？意味着之后再继续跟任意500个任意长度的字符串都不会影响其最终Simhash值为当前值</strong><br>所以可以构建两个任意比如1千个汉字2个为一组，加在500个“he”之后，他们Simhash值是一样的，但是内容确实一半完全不一样！<br><strong>那么非极端情况会怎样？</strong><br>下面是我从西游记某章切分2500多个词作为输入，基于Apache codec的murmur hash64后得到的simhash的最终weight数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[176, 192, 124, -62, 322, 152, 60, -74, -594, 96, -144, 206, 84, -164, -168, -48, -602, -118, -84, -102, 122, 384, -260, 428, 28, -112, -420, -64, -110, 218, -68, 552, 156, 62, -40, 438, 200, 146, 58, 574, 210, 54, -452, 28, -54, -290, -200, 114, 50, -138, -264, -68, -108, 20, -206, -282, -150, 742, 126, -228, 58, 400, -264, -32]</span><br></pre></td></tr></table></figure>
<p>Simhash算法常规每次增减1，从这个数组可以看到，最小的weight[i]是20，<strong>假设再继续输入字符串，幸运的话，至少需要 20 次输入才能造成1个bit变化，最少再有32次输入造成2个位反转</strong>…<br>这是理想情况，实际我测试了5000次下来，每次从中文汉字中随机选一个字符加入，知道增加至1000个汉字，观察下来平均是第327个字才稳定在2bit不同，而前1000字稳定在5bit不同。<br>所以我的建议是，使用64位的Simhash时：</p>
<ul>
<li><strong>Simhash输入列表不应过大，过大可能导致不准确</strong>，hamming distance也需要限制大小，具体看经验值了。推荐是7，但是3以内也可能不可信</li>
<li><strong>某一个词分配权重&#x2F;次数不应过大</strong>。如上面权重100，表示后面可能再输入99次都不会改变一个bit值</li>
</ul>
<h3 id="hash算法影响结果"><a href="#hash算法影响结果" class="headerlink" title="hash算法影响结果"></a>hash算法影响结果</h3><p>HanLP+Simhash <strong>实际跑出来结果是 C7和D3最匹配而不是D8</strong>，下面是hanlp分词结果(重复是因为配了权重X2)，这里看到有同义词转换，前面提到归一化的同义词不会低于原有相似，但是看下面结果不难看出C7&#x2F;D8应该更相似, 二者Jacard相似度接近0.6，而C7和D3的jacard相似度0.2不到，可以说差之千里了。当然是受hash算法的结果在0&#x2F;1选择超平面影响导致（整体结果导致如此，但去掉D3中四个“孙悟空”，相似度确实降了0.3了），<strong>上面示例SimHash使用的哈希算法其实是Python的默认hash算法，使用还是上个世纪哈希常用的“大质数”-1000003，而FastSimhash方法则能匹配到D8， 这也验证了实验数据所表明的Simhash在小文本输入存在误差不准确的问题</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c7 = (<span class="string">&quot;普京&quot;</span>, <span class="string">&quot;普京&quot;</span>, <span class="string">&quot;与&quot;</span>, <span class="string">&quot;克林顿&quot;</span>, <span class="string">&quot;克林顿&quot;</span>, <span class="string">&quot;没有&quot;</span>, <span class="string">&quot;参与&quot;</span>, <span class="string">&quot;进来&quot;</span>, <span class="string">&quot;因为&quot;</span>, <span class="string">&quot;锦苑&quot;</span>, <span class="string">&quot;锦苑&quot;</span>, <span class="string">&quot;中学&quot;</span>,<span class="string">&quot;中学&quot;</span>, <span class="string">&quot;司马迁&quot;</span>, <span class="string">&quot;司马迁&quot;</span>, <span class="string">&quot;和&quot;</span>, <span class="string">&quot;孙权&quot;</span>, <span class="string">&quot;孙权&quot;</span>, <span class="string">&quot;不再&quot;</span>, <span class="string">&quot;来&quot;</span>, <span class="string">&quot;玩&quot;</span>,<span class="string">&quot;你&quot;</span>, <span class="string">&quot;说&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;也&quot;</span>, <span class="string">&quot;不是&quot;</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;去&quot;</span>, <span class="string">&quot;了&quot;</span>, <span class="string">&quot;松江府&quot;</span>, <span class="string">&quot;松江府&quot;</span>, <span class="string">&quot;还&quot;</span>, <span class="string">&quot;没&quot;</span>, <span class="string">&quot;来得及&quot;</span>, <span class="string">&quot;说&quot;</span>, <span class="string">&quot;一首&quot;</span>);</span><br><span class="line">d8 = (<span class="string">&quot;普京&quot;</span>, <span class="string">&quot;普京&quot;</span>, <span class="string">&quot;与&quot;</span>, <span class="string">&quot;克林顿&quot;</span>, <span class="string">&quot;克林顿&quot;</span>, <span class="string">&quot;没有&quot;</span>, <span class="string">&quot;达成&quot;</span>, <span class="string">&quot;因为&quot;</span>, <span class="string">&quot;普通&quot;</span>, <span class="string">&quot;情理&quot;</span>,<span class="string">&quot;情理&quot;</span>, <span class="string">&quot;不&quot;</span>, <span class="string">&quot;允许&quot;</span>, <span class="string">&quot;司马迁&quot;</span>, <span class="string">&quot;司马迁&quot;</span>, <span class="string">&quot;和&quot;</span>, <span class="string">&quot;孙权&quot;</span>, <span class="string">&quot;孙权&quot;</span>, <span class="string">&quot;不是&quot;</span>, <span class="string">&quot;一路人&quot;</span>,<span class="string">&quot;一路人&quot;</span>, <span class="string">&quot;听&quot;</span>,<span class="string">&quot;了&quot;</span>, <span class="string">&quot;松江府&quot;</span>,<span class="string">&quot;松江府&quot;</span>, <span class="string">&quot;的&quot;</span>, <span class="string">&quot;宋江说来说去&quot;</span>, <span class="string">&quot;宋江说来说去&quot;</span>, <span class="string">&quot;不&quot;</span>, <span class="string">&quot;明白&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;还是&quot;</span>, <span class="string">&quot;不是&quot;</span>);</span><br><span class="line">d3 = (<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;每天&quot;</span>,<span class="string">&quot;和&quot;</span>,<span class="string">&quot;门生&quot;</span>,<span class="string">&quot;门生&quot;</span>,<span class="string">&quot;们&quot;</span>,<span class="string">&quot;待&quot;</span>,<span class="string">&quot;在&quot;</span>,<span class="string">&quot;一起&quot;</span>,<span class="string">&quot;打扫&quot;</span>,<span class="string">&quot;院子&quot;</span>,<span class="string">&quot;院子&quot;</span>,<span class="string">&quot;养花&quot;</span>,<span class="string">&quot;养花&quot;</span>,<span class="string">&quot;修树&quot;</span>,<span class="string">&quot;修树&quot;</span>,<span class="string">&quot;挑水&quot;</span>,<span class="string">&quot;捡&quot;</span>,<span class="string">&quot;柴&quot;</span>,<span class="string">&quot;学&quot;</span>,<span class="string">&quot;经论&quot;</span>,<span class="string">&quot;经论&quot;</span>,<span class="string">&quot;道&quot;</span>,<span class="string">&quot;不知不觉&quot;</span>,<span class="string">&quot;过去&quot;</span>,<span class="string">&quot;了&quot;</span>,<span class="string">&quot;七&quot;</span>,<span class="string">&quot;年&quot;</span>,<span class="string">&quot;时间&quot;</span>,<span class="string">&quot;时间&quot;</span>,<span class="string">&quot;一&quot;</span>,<span class="string">&quot;天&quot;</span>,<span class="string">&quot;菩提&quot;</span>,<span class="string">&quot;老祖&quot;</span>,<span class="string">&quot;老祖&quot;</span>,<span class="string">&quot;对&quot;</span>,<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;说&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面是分词+权重的结果。<br><strong>所以最终没有选择Simhash作为相似度比较方案</strong></p>
<h3 id="效果-总结"><a href="#效果-总结" class="headerlink" title="效果&#x2F;总结"></a>效果&#x2F;总结</h3><ul>
<li>每天作家修改内容，影响的评论大概2-3万，使用编辑距离计算相似度算法，导致相似度匹配较低而无法匹配段，而<strong>删除的评论大约每天7500+，在增加LCS&#x2F;TFIDF算法之后，每天大约挽回6300条评论</strong>，剩下占比较高的还是段删除、改动较大。使用TFIDF效果不稳定，6300条中大部分是LCS匹配的，</li>
<li>新词发现或者基于BERT做匹配是后续努力的方向</li>
</ul>
<p>** 遵循CC协议，转载请标注来源 **</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://thomaslau.github.io/2025/01/02/2025-01-02-on_text_similarity/" data-id="cm8lvsawc0000nnxae8cm5rp1" data-title="如何做好网文段落匹配" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TextSimilarity/" rel="tag">TextSimilarity</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/02/14/2025-02-14-on_computor_time/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算机时间捡拾
        
      </div>
    </a>
  
  
    <a href="/2020/11/10/2020-11-10-on_chain_of_trust/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">软件研发中的信任链问题</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/17monipdb/" rel="tag">17monipdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-Tree/" rel="tag">B Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigData/" rel="tag">BigData</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BlogDigests/" rel="tag">BlogDigests</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS-SSO/" rel="tag">CAS SSO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Consistent-Hashing/" rel="tag">Consistent Hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashTable/" rel="tag">HashTable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hyperloglog/" rel="tag">Hyperloglog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-Flame-Graph/" rel="tag">JAVA Flame Graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JIT/" rel="tag">JIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JMH/" rel="tag">JMH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPG-DCT/" rel="tag">JPG&#x2F;DCT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leaky/" rel="tag">Leaky</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/" rel="tag">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lucene/" rel="tag">Lucene</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ML/" rel="tag">ML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Minhash/" rel="tag">Minhash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monte-Carlo/" rel="tag">Monte Carlo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-hashCode/" rel="tag">Object.hashCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RedisCluster/" rel="tag">RedisCluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RedisLua/" rel="tag">RedisLua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/" rel="tag">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SimHash/" rel="tag">SimHash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tech/" rel="tag">Tech</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TextSimilarity/" rel="tag">TextSimilarity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thoughts/" rel="tag">Thoughts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/" rel="tag">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/antirez/" rel="tag">antirez</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bloomfilter/" rel="tag">bloomfilter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/geohash/" rel="tag">geohash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/guava/" rel="tag">guava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/guava-ratelimiter/" rel="tag">guava ratelimiter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash/" rel="tag">hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/" rel="tag">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pHash-dHash/" rel="tag">pHash&#x2F;dHash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ratelimiter/" rel="tag">ratelimiter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/roaringbitmap/" rel="tag">roaringbitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql-count/" rel="tag">sql.count</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/twitter/" rel="tag">twitter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unix-Epoch/" rel="tag">unix Epoch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weeklyreading/" rel="tag">weeklyreading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yearly/" rel="tag">yearly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%8F%B0/" rel="tag">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E8%A8%80%E7%A2%8E%E8%AF%AD/" rel="tag">碎言碎语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B0%E7%A7%92/" rel="tag">闰秒</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%84%9F/" rel="tag">随感</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/17monipdb/" style="font-size: 10px;">17monipdb</a> <a href="/tags/B-Tree/" style="font-size: 10px;">B Tree</a> <a href="/tags/BigData/" style="font-size: 10px;">BigData</a> <a href="/tags/BlogDigests/" style="font-size: 10px;">BlogDigests</a> <a href="/tags/CAS-SSO/" style="font-size: 10px;">CAS SSO</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/Consistent-Hashing/" style="font-size: 10px;">Consistent Hashing</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Elasticsearch/" style="font-size: 14px;">Elasticsearch</a> <a href="/tags/HashTable/" style="font-size: 10px;">HashTable</a> <a href="/tags/Hyperloglog/" style="font-size: 10px;">Hyperloglog</a> <a href="/tags/JAVA-Flame-Graph/" style="font-size: 10px;">JAVA Flame Graph</a> <a href="/tags/JIT/" style="font-size: 10px;">JIT</a> <a href="/tags/JMH/" style="font-size: 10px;">JMH</a> <a href="/tags/JPG-DCT/" style="font-size: 10px;">JPG/DCT</a> <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Leaky/" style="font-size: 10px;">Leaky</a> <a href="/tags/Life/" style="font-size: 16px;">Life</a> <a href="/tags/Lucene/" style="font-size: 12px;">Lucene</a> <a href="/tags/ML/" style="font-size: 12px;">ML</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Minhash/" style="font-size: 10px;">Minhash</a> <a href="/tags/Monte-Carlo/" style="font-size: 10px;">Monte Carlo</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 12px;">Nginx</a> <a href="/tags/Object-hashCode/" style="font-size: 10px;">Object.hashCode</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Redis/" style="font-size: 12px;">Redis</a> <a href="/tags/RedisCluster/" style="font-size: 10px;">RedisCluster</a> <a href="/tags/RedisLua/" style="font-size: 10px;">RedisLua</a> <a href="/tags/Security/" style="font-size: 12px;">Security</a> <a href="/tags/SimHash/" style="font-size: 10px;">SimHash</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/SpringSecurity/" style="font-size: 10px;">SpringSecurity</a> <a href="/tags/Tech/" style="font-size: 20px;">Tech</a> <a href="/tags/TextSimilarity/" style="font-size: 10px;">TextSimilarity</a> <a href="/tags/Thoughts/" style="font-size: 10px;">Thoughts</a> <a href="/tags/Tools/" style="font-size: 14px;">Tools</a> <a href="/tags/antirez/" style="font-size: 12px;">antirez</a> <a href="/tags/architecture/" style="font-size: 12px;">architecture</a> <a href="/tags/bloomfilter/" style="font-size: 10px;">bloomfilter</a> <a href="/tags/elasticsearch/" style="font-size: 12px;">elasticsearch</a> <a href="/tags/geohash/" style="font-size: 10px;">geohash</a> <a href="/tags/guava/" style="font-size: 10px;">guava</a> <a href="/tags/guava-ratelimiter/" style="font-size: 10px;">guava ratelimiter</a> <a href="/tags/hash/" style="font-size: 10px;">hash</a> <a href="/tags/kafka/" style="font-size: 12px;">kafka</a> <a href="/tags/life/" style="font-size: 12px;">life</a> <a href="/tags/pHash-dHash/" style="font-size: 10px;">pHash/dHash</a> <a href="/tags/performance/" style="font-size: 10px;">performance</a> <a href="/tags/ratelimiter/" style="font-size: 12px;">ratelimiter</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/roaringbitmap/" style="font-size: 10px;">roaringbitmap</a> <a href="/tags/sql-count/" style="font-size: 10px;">sql.count</a> <a href="/tags/twitter/" style="font-size: 10px;">twitter</a> <a href="/tags/unix-Epoch/" style="font-size: 10px;">unix Epoch</a> <a href="/tags/weeklyreading/" style="font-size: 18px;">weeklyreading</a> <a href="/tags/yearly/" style="font-size: 10px;">yearly</a> <a href="/tags/%E4%B8%AD%E5%8F%B0/" style="font-size: 10px;">中台</a> <a href="/tags/%E7%A2%8E%E8%A8%80%E7%A2%8E%E8%AF%AD/" style="font-size: 10px;">碎言碎语</a> <a href="/tags/%E9%97%B0%E7%A7%92/" style="font-size: 10px;">闰秒</a> <a href="/tags/%E9%9A%8F%E6%84%9F/" style="font-size: 12px;">随感</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/14/2025-02-14-on_computor_time/">计算机时间捡拾</a>
          </li>
        
          <li>
            <a href="/2025/01/02/2025-01-02-on_text_similarity/">如何做好网文段落匹配</a>
          </li>
        
          <li>
            <a href="/2020/11/10/2020-11-10-on_chain_of_trust/">软件研发中的信任链问题</a>
          </li>
        
          <li>
            <a href="/2020/10/23/2020-10-23-on_middle_platform/">什么是中台</a>
          </li>
        
          <li>
            <a href="/2020/09/21/2020-09-21-on_consistent_hash/">正确理解一致性哈希</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Thomas Lau<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!doctype html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Tech,weeklyreading," />





  <link rel="alternate" href="/atom.xml" title="e+Thomas" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon32.ico?v=5.1.1" />






<meta name="description" content="阿里周洋分享了中间件技术峰会分享|双11高可用架构演进之路, 介绍了阿里第四代技术架构，将其分为了，容量规划、限流降级、依赖治理、开关预案、故障演练、流量调度。其实这是一系列，另外一篇中间件技术峰会分享|阿里电商架构演变之路，很简略的概括了阿里架构史，其实也是国内很多公司开发的架构史。里面将淘宝架构分为：淘宝从初创开始到今天，我们的技术架构总体上经历了四代：第一代是基于LAMP的一套结构。第二代">
<meta name="keywords" content="Tech,weeklyreading">
<meta property="og:type" content="article">
<meta property="og:title" content="Weekly Reading 170820">
<meta property="og:url" content="http://thomaslau.github.io/2017/08/20/2017-08-20-weekly_reading/index.html">
<meta property="og:site_name" content="e+Thomas">
<meta property="og:description" content="阿里周洋分享了中间件技术峰会分享|双11高可用架构演进之路, 介绍了阿里第四代技术架构，将其分为了，容量规划、限流降级、依赖治理、开关预案、故障演练、流量调度。其实这是一系列，另外一篇中间件技术峰会分享|阿里电商架构演变之路，很简略的概括了阿里架构史，其实也是国内很多公司开发的架构史。里面将淘宝架构分为：淘宝从初创开始到今天，我们的技术架构总体上经历了四代：第一代是基于LAMP的一套结构。第二代">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-30T00:58:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Weekly Reading 170820">
<meta name="twitter:description" content="阿里周洋分享了中间件技术峰会分享|双11高可用架构演进之路, 介绍了阿里第四代技术架构，将其分为了，容量规划、限流降级、依赖治理、开关预案、故障演练、流量调度。其实这是一系列，另外一篇中间件技术峰会分享|阿里电商架构演变之路，很简略的概括了阿里架构史，其实也是国内很多公司开发的架构史。里面将淘宝架构分为：淘宝从初创开始到今天，我们的技术架构总体上经历了四代：第一代是基于LAMP的一套结构。第二代">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thomaslau.github.io/2017/08/20/2017-08-20-weekly_reading/"/>





  <title>Weekly Reading 170820 | e+Thomas</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?22bda74eb54c0d90672fd5c06458004c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">e+Thomas</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thomaslau.github.io/2017/08/20/2017-08-20-weekly_reading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Thomas Lau">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myLogo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="e+Thomas">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Weekly Reading 170820</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:59:07+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li>阿里周洋分享了<a href="http://jm.taobao.org/2017/08/08/080802/?from=thomaslau.gigthub.io" target="_blank" rel="external">中间件技术峰会分享|双11高可用架构演进之路</a>, 介绍了阿里第四代技术架构，将其分为了，容量规划、限流降级、依赖治理、开关预案、故障演练、流量调度。<br>其实这是一系列，另外一篇<a href="http://jm.taobao.org/2017/08/09/20170809/?from=thomaslau.gigthub.io" target="_blank" rel="external">中间件技术峰会分享|阿里电商架构演变之路</a>，很简略的概括了阿里架构史，其实也是国内很多公司开发的架构史。里面将淘宝架构分为：<br><strong>淘宝从初创开始到今天，我们的技术架构总体上经历了四代：<br>第一代是基于LAMP的一套结构。第二代是基于Java的应用架构。第三代是基于分布式体系，构建出一整套的分布式架构。第四代是基于IDC，不但应用能够分布，整数数据中心也能够分布。</strong><br>这里也可以看出，前三代，阿里跟随国外技术圈。本人工作过几家大公司其实也是该思路。</li>
<li><p><a href="https://www.youtube.com/watch?v=OYpTn0nWKR4" target="_blank" rel="external">10,000 Java performance tips over 15 years - what did I learn</a><br>上面是油管链接，也可以去<a href="https://www.voxxed.com/2017/07/10000-java-performance-tips-15-years/" target="_blank" rel="external">voxxed 2017</a>, <a href="https://cfp.devoxx.co.uk/2017/talks/conf" target="_blank" rel="external">devoxx conf</a>上面一些基于JVM语言／优化等链接还是很值得看的。</p>
<a id="more"></a>
<p>作者简介: Jack Shirazi<br>Head of Engineering for Nexmo, the Vonage API, Java Champion since 2005,Founder of javaperformancetuning.com,Author of Java Performance Tuning (O’Reilly),JUG Leader.<br>视频和ppt很值得一看，列举了JAVA优化（主要基于JVM／OS等层面）常见的方法，虽然许多介绍属于蜻蜓点水式的，但作为日常JAVA性能优化参考指南的需求还是可以的。<a href="／images/Devoxx-UK-2017.pdf">这里</a>的链接，以便不好翻墙或查找困难。</p>
</li>
<li><p><a href="https://coderbee.net/index.php/db/20170818/1539" target="_blank" rel="external">MySQL 高性能的索引策略</a>，总结了MySQL高效索引创建约定，很全面了。许多开发，存储上来首选就是NoSQL等，我觉得MySQL依旧是高并发的首选，只要你对设计得当。<br>“在选择和编写利用索引的查询时，记住下面三个原则：<br>a)单行访问是很慢的。（特别是机械硬盘存储，SSD 的随机 I/O 快很多，不过这点仍然成立。）最好读取的块中包含尽可能多所需的行。使用索引可以创建位置引用以提升效率。<br>b)按顺序访问范围数据是很快的。原因：1，顺序 I/O 不需要多次磁盘寻道，所以比随机 I/O 快很多（特别是机械硬盘）；2，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 group by 查询也无须再做排序和将行按组进行聚合计算。<br>c)索引覆盖查询是很快的。存储引擎不需要回表查找行。”</p>
</li>
<li><p><a href="http://blog.csdn.net/defonds/article/details/76247842" target="_blank" rel="external">Linux 如何添加一个 Swap 文件 - Defonds 的专栏</a>, 有些情况下，一些开发人员会选择增加swap空间以提升Linux 服务器/桌面系统的性能。本文作者翻译nixCraft创始人Vivek Gite在不创建一个新的分区的前提下添加一个swap文件到Linux系统的文章。<br>虽然有人也强调过多的swap甚至swap有害，不过对个人桌面系统／非大型应用，本文值得一看。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># dd if=/dev/zero of=/swapfile1 bs=1024 count=524288</span></div><div class="line"><span class="comment"># chown root:root /swapfile1 //为交换文件设置合适的文件权限</span></div><div class="line"><span class="comment"># chmod 0600 /swapfile1  //为交换文件设置合适的文件权限</span></div><div class="line"><span class="comment"># mkswap /swapfile1   //设置一个 Linux 交换区域</span></div><div class="line"><span class="comment"># swapon /swapfile1   //启用交换文件</span></div><div class="line"><span class="comment"># vi /etc/fstab       //修改 /etc/fstab 文件</span></div><div class="line">追加一行：</div><div class="line">/swapfile1 none swap sw 0 0</div><div class="line">$ free -m</div><div class="line"><span class="comment"># swapon -s           //如何显示 Linux 上交换区的使用摘要</span></div><div class="line"><span class="comment"># --</span></div><div class="line"><span class="comment"># swapoff /swapfile1  //关闭 Linux 上用于 page 分页以及交换区域的设备和文件</span></div><div class="line"><span class="comment"># swapon -s</span></div></pre></td></tr></table></figure>
</li>
<li><p>发表在IBM dw上的文章 <a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html" target="_blank" rel="external">为什么完美的lambda表达式只有一行</a><br>作者列举了充满危险的长lambda表达式（该用拆分短小的）, 值得借鉴。<br>不过，如果跟着作者的思路／需求来看，作者说的却是是有道理的，但可惜的是如果我们跳出 lambda函数的范畴，就会发现，或者实践中会发现，其实这么做坏处更多，<a href="https://medium.com/@cindysridharan/small-functions-considered-harmful-91035d316c29" target="_blank" rel="external">这里有篇文章可以解释</a>, 挺欣赏后者对DRY原则和“GoF”的Design Pattern的“have largely gone unchallenged for decades now and direly require reconsideration, especially so since the programming landscape as well as paradigms have evolved vastly in the recent years”质疑态度，如果你真的阅读并写过代码的话，作者质疑了程序员还在奉为圣经的《clean code》，Martin Fowler的function length讨论。在实际开发中，flexibility to accommodate any changes以及可持续／可控的修改也很重要，所以，我认为关键是作出好的Abstraction，不仅仅是模型的抽象，还有架构／代码／变与不变的抽象，受编程书以及大公司教条的误导，有的开发过分关注 int xxx =100这样“写死了”的问题，其实比这更严重的是代码组织架构组织架构死了，才是更严重问题，毕竟前者就算hard code，可是代码改起来好改。所以关键是要做好“Abstraction”。</p>
</li>
<li><p>kafka-exactly-once引发的争吵。<br>一个老生常谈的问题，源于kafka官宣<a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/" target="_blank" rel="external">Exactly-once Semantics are Possible: Here’s How Kafka Does it</a>kafka 0.11版本引入exactly once的实现“we have hit an exciting milestone the Kafka community has long been waiting for: we have  introduced exactly-once semantics in Apache Kafka in the 0.11 release ”, 可以说是企图对消息幂等思考的致以尾声，并实现:正好一次传递与事务性消息。<br>之后引发许多讨论<a href="https://www.reddit.com/r/programming/comments/6kh65f/exactlyonce_semantics_is_possible_heres_how/" target="_blank" rel="external">Reddit</a>/<a href="https://news.ycombinator.com/item?id=14670801" target="_blank" rel="external">HN</a>， 更多人质疑这是对 FLP理论或两个拜占庭将军的问题的违反，Kafka的co-creator Jay Kreps发文做了解释<a href="https://medium.com/@jaykreps/exactly-once-support-in-apache-kafka-55e1fdd0a35f" target="_blank" rel="external">exactly-once-support-in-apache-kafka</a>。<br>更多：<a href="https://softwaremill.com/what-kafka-exactly-once-really-means/" target="_blank" rel="external">what-kafka-exactly-once-really-means</a>,里面:</p>
<pre><code>The features which make the above possible are:
a)idempotent producers (introduced in 0.11)
b)transactions across partitions (introduced in 0.11)
c)Kafka-based offset storage (introduced in 0.8.1.1)
Let’s see which of these features are useful at which stage of an exactly-once processing pipeline.
</code></pre><p><a href="http://the-paper-trail.org/blog/exactly-not-atomic-broadcast-still-impossible-kafka/" target="_blank" rel="external">Exactly-once or not, atomic broadcast is still impossible in Kafka – or anywhere</a>, ZK的PMC Flavio Junqueira argued that <a href="https://fpj.me/2017/07/04/no-consensus-in-exactly-once/" target="_blank" rel="external">No consensus in exactly-once</a>.<br><a href="http://bravenewgeek.com/you-cannot-have-exactly-once-delivery-redux/" target="_blank" rel="external">You Cannot Have Exactly-Once Delivery Redux</a>里作者将该问题归结为“Exactly-once delivery” and “Exactly-once processing”. 文章虽简单，但是涉及许多分布式知识。</p>
<pre><code>“Delivery” is a transport semantic. “Processing” is an application semantic.
“Exactly-once delivery” is a poor term. The word “delivery” is overloaded. 
Frankly, I think it’s a marketing word. The better term is “exactly-once processing.” 
Some call the distinction pedantic, but I think it’s important and there is some nuance. 
Kafka did not solve the Two Generals Problem. Exactly-once delivery, at the transport level, is impossible. 
It doesn’t exist in any meaningful way and isn’t all that interesting to talk about. 
“We have a word for infinite packet delay—outage,” as Jay puts it. That’s why TCP exists, 
but TCP doesn’t care about your application semantics. 
And in the end, that’s what’s interesting—application semantics. 
My problem with “exactly-once delivery” is it assumes too much, 
which causes a lot of folks to make bad assumptions. 
“Delivery” is a transport semantic. “Processing” is an application semantic.
...
To achieve exactly-once processing semantics, 
we must have a closed system with end-to-end support for modeling input, 
output, and processor state as a single, atomic operation. 
Kafka supports this by providing a new transaction API and idempotent producers. 
...
Exactly-once processing is an end-to-end guarantee and the application 
has to be designed to not violate the property as well. If you are using the consumer API, 
this means ensuring that you commit changes to your application state 
concordant with your offsets as described here.
</code></pre><p>最后，Jay Kreps写了第二篇文章作解释，<a href="https://medium.com/@jaykreps/exactly-once-one-more-time-901181d592f9" target="_blank" rel="external">exactly-once-one-more-time</a></p>
<pre><code>We think the factoring of the problem into two pieces makes this far far easier:
a)Processing using the streams api
b)Connectors using the connect api
This makes guarantees for processing quite transparent (you just set a config to enable it). 
The only real restriction is that you must maintain state using the provided facilities.
Connectors require more thought about the interaction between Kafka and the external system 
but these can be made reusable. So if one person has implemented a Kafka=&gt;Mysql connector 
and tested it everyone else can just use that.
</code></pre><p>这里<a href="https://tech.meituan.com/distributed_queue_based_programming-optimization.html" target="_blank" rel="external">美团消息队列的扫盲贴</a>, 忘记了RocketMQ曾声称自己是exactly once还是消息顺序可保证了。</p>
</li>
<li>对上面补充，一篇很好的中文介绍 <a href="http://danielw.cn/FLP-proof" target="_blank" rel="external">FLP Impossibility的证明</a>，<a href="http://blog.csdn.net/chen77716/article/details/27963079" target="_blank" rel="external">FLP Impossibility</a>作为分布式重要定理<br>FLP 不可能原理：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。<br>不可能原理实际上告诉人们，不要浪费时间去为异步分布式系统设计在任意场景下都能实现共识的算法. 不过作为细化，CAP定理则相当于在实践中提供了一个几乎可以打破FLP问题的解决方案。</li>
<li>the morning paper，为作者叹，能有这么多时间去读paper，关键是精力涉及面如此之广<br><a href="http://blog.acolyer.org/2017/08/08/a-general-purpose-counting-filter-making-every-bit-count" target="_blank" rel="external">A better, faster, smaller Approximate Membership Query data structure - time to retire your Bloom filters</a>, 我们知道，在Approximate Membership Query (AMQ) data structures的需求里，许多追求高性能的系统喜欢用Bloom Filter作为去重方法，但是作为m位BitSet这样简单数据结构，支持插入和查找两种操作， 这在在需要经常变动（增删）的数据集中，Bloom Filter性能不如其改进版Cuckoo Filter，这篇文章介绍了类似Cuckoo Filter的数据结构Counting Quotient Filter，不过原论文好像被删除了。</li>
<li><a href="https://shipilev.net/jvm-anatomy-park/2-transparent-huge-pages/" target="_blank" rel="external">JVM Anatomy Park #2: Transparent Huge Pages
</a> JVM Anatomy Park系列文章第二篇，实验了并讨论对于java应用：What are Large Pages? What are Transparent Huge Pages? How does it help me?!</li>
<li><a href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iii.html" target="_blank" rel="external">对LogLog Counting的进一步理解</a>, 理解Hyperloglog Counting, Redis也引入非常节约资源的Hyperloglog，不过Hyperloglog只能Counting，实际还是鸡肋的。</li>
<li><a href="http://ifeve.com/classloader%E8%A7%A3%E6%83%91/" target="_blank" rel="external">ifeve的ClassLoader解惑</a><br>介绍了java classloader一些问题，不过文中举例可惜没有提到著名的SlF4j面对的classloader问题。<br>另介绍了Tomcat的ClassLoader。<pre><code>总结下，默认情况下tomcat中commonloader,sharedloader,catalinaloader是同一个加载器，
其类查找路径都是同一个地方。其实catalinaloader主要工作应该是加载tomcat本身启动所需要的类，
而sharedloader是webappclassloader的父类，所以应该是加载一些所有webap共享的类，而commonlaoder作为
sharedloader,catalinaloader的父类，自然设计目的是为了加载二者共享的类。所以如果能恰当的使用tomcat中设计的这种策略，
修改catalina.properites中三种加载器类加载路径，就会真正达到这种设计效果
</code></pre></li>
<li><p>另一篇介绍SpringBoot Classloader的文章<a href="http://blog.csdn.net/hengyunabc/article/details/77413669" target="_blank" rel="external">深入Spring Boot：ClassLoader的继承关系和影响</a><br>总结spring boot里ClassLoader的继承关系<br>a)在IDE里main函数执行时，只有一个ClassLoader，也就是SystemClassLoader<br>b)在以fat jar运行时，有一个LaunchedURLClassLoader，它的parent是SystemClassLoader<br>LaunchedURLClassLoader的urls是fat jar里的BOOT-INF/classes和BOOT-INF/lib下的jar。<br>SystemClassLoader的urls是fat jar本身。<br>c)在解压目录运行时，和fatjar类似，不过url都是目录形式。目录形式会有更好的兼容性。<br>spring boot 1.3.<em> 和 1.4.</em> 版本的区别<br>在1.3.<em> 版本里应用的类和loader的类都是打包在一个fat jar里应用依赖的jar放在fat jar里的/lib下面。<br>1.4.</em> 版本后loader的类放在fat jar里应用的类打包放在fat jar的BOOT-INF/classes目录里<br>应用依赖的jar放在fat jar里的/lib下面。<br>带来的问题<br>a)demo.jar!/BOOT-INF/classes!/ 这样子url不工作<br>b)demo.jar!/META-INF/resources 下的资源问题<br>c)getResource(“”) 和 getResources(“”) 的返回值的问题<br>d)类似 classpath<em>:*</em>-service.xml 的通配问题</p>
</li>
<li><p>入门tf。<br><a href="http://www.pinchofintelligence.com/detecting-bats-recognising-sound-tensorflow/" target="_blank" rel="external">http://www.pinchofintelligence.com/detecting-bats-recognising-sound-tensorflow/</a><br><a href="https://medium.com/towards-data-science/how-to-build-a-dynamic-garden-using-machine-learning-d589468f7c04" target="_blank" rel="external">https://medium.com/towards-data-science/how-to-build-a-dynamic-garden-using-machine-learning-d589468f7c04</a><br><a href="https://medium.com/towards-data-science/number-plate-detection-with-supervisely-and-tensorflow-part-1-e84c74d4382c" target="_blank" rel="external">https://medium.com/towards-data-science/number-plate-detection-with-supervisely-and-tensorflow-part-1-e84c74d4382c</a></p>
</li>
<li>来自<a href="https://huoding.com/2017/08/13/628" target="_blank" rel="external">火丁笔记的SYN和RTO问题</a><br>RTO的最大值是 120 秒，最小值是 200 毫秒，在建立连接后，因为目前网络都很快，所以大部分连接的<br>RTO 都会接近 TCP_RTO_MIN，也就是 200ms，可以通过「ss -int」命令来确认</li>
<li><a href="http://developer.lightbend.com/blog/2017-08-11-sbt-1-0-0/" target="_blank" rel="external">http://developer.lightbend.com/blog/2017-08-11-sbt-1-0-0/</a></li>
<li><a href="https://pragmaticintegrator.wordpress.com/2017/08/13/small-hack-to-avoid-ssl-validation-in-spring-resttemplate/" target="_blank" rel="external">https://pragmaticintegrator.wordpress.com/2017/08/13/small-hack-to-avoid-ssl-validation-in-spring-resttemplate/</a></li>
<li>该来的终究要来的。<a href="https://www.azul.com/jdk-9-pitfalls-for-the-unwary/" target="_blank" rel="external">JDK 9: Pitfalls For The Unwary</a>, infoq的一篇<a href="http://www.infoq.com/cn/presentations/introduction-of-java9-new-features-jigsaw" target="_blank" rel="external">Java 9 新特性介绍及 Jigsaw 一览</a></li>
<li><a href="http://blog.jobbole.com/112170/" target="_blank" rel="external">cp 命令两个高效的用法</a><br>cp -r Misc /media/clh/4388-D5FE //更新你的文件夹<br>cp –force –backup=numbered test1.py test1.py //版本备份</li>
<li>没想到啊，一致性还分这么多种类！<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-cassandra3x1/index.html?from=thomaslau.github.io" target="_blank" rel="external">casanddra 跟最终一致性</a><br>Cassandra 被称为”最终一致性”，有点误导人，Cassandra 一致性是可以调整的。<br>那么什么是一致性？现实世界是按照一致性的级别进行衡量的，最终一致性是几种一致性模型的一种：<br><strong>严格一致性（Strict Consistency）</strong>：所有的请求必须按照线性方式执行。读出的数据始终为最近写入的数据。<br>这种一致性只有全局时钟存在时才有可能，在分布式网络环境不可能实现；<br><strong>顺序一致性（Sequential Consistency）</strong>：所有使用者以同样的顺序看到对统一数据的操作，但是该顺序不一定是实时的；<br><strong>因果一致性（Causal Consistency）</strong>：只有存在因果关系的写操作才要求所有使用者以相同的次序看到，对于无因果关系的写入则并行进行，<br>无次序保证。因果一致性可以看作是对顺序一致性功能的一种优化，但是在实现时必须建立与维护因果依赖图，是相当困难的；<br><strong>管道一致性（PRAM/FIFO Consistency）</strong>：在因果一致性模型上的进一步弱化，要求由某一个使用者完成的写操作可以被其他所有的使用者按照顺序感知到，<br>而从不同使用者中来的写操作则无需保证顺序，就像一个一个的管道一样。相对来说比较容易实现；<br><strong>弱一致性（Weak Consistency）</strong>：只要求对共享数据结构的访问保证顺序一致性。对于同步变量的操作具有顺序一致性，<br>是全局可见的，且只有当没有写操作等待处理时才可进行，以保证对于临界区域的访问顺序进行。<br>在同步时点，所有使用者可以看到相同的数据；<br><strong>释放一致性（Release Consistency）</strong>：弱一致性无法区分使用者是要进入临界区还是要出临界区，释放一致性使用两个不同的操作语句进行了区分。<br>需要写入时使用者 acquire 该对象，写完后 release，acquire-release 之间形成了一个临界区，<br>提供释放一致性也就意味着当 release 操作发生后，所有使用者应该可以看到该操作；<br><strong>最终一致性（Eventual Consistency）</strong>：所有的复制都会在分布式系统内部传播数据，但是需要花点时间，最终所有节点的副本数据会实现一致。<br>当没有新更新的情况下，更新最终会通过网络传播到所有副本点，所有副本点最终会一致，也就是说，<br>使用者在最终某个时间点前的中间过程中无法保证看到的是新写入的数据。可以采用最终一致性模型有一个关键要求，<br>需要用户可以接受读出陈旧数据；<br><strong>Delta 一致性</strong>：系统会在 Delta 时间内达到一致。这段时间内会存在一个不一致的窗口，该窗口可能是因为日志迁移的过程导致的。<br><strong>最终一致性的几种具体实现</strong>：<br><strong>读不旧于写一致性（Read-your-writes consistency）</strong>：使用者读到的数据，总是不旧于自身上一个写入的数据。<br><strong>会话一致性（Session Consistency）</strong>：比读不旧于写一致性更弱化。使用者在一个会话中才保证读写一致性，启动新会话后则无需保证。<br><strong>单读一致性（Monotonic Read Consistency）</strong>：读到的数据总是不旧于上一次读到的数据。<br><strong>单写一致性（Monotonic Write Consistency）</strong>：写入的数据完成后才能开始下一次的写入。<br><strong>写不旧于读一致性（Writes-follow-reads Consistency）</strong>：写入的副本不旧于上一次读到的数据，即不会写入更旧的数据。<br>Cassandra 把一致性级别的决定权交到了客户端手中，这意味着客户决定每一次操作的一致性级别，即决定写入操作过程中集群内部必须有多少份副本完成才能响应读请求。如果客户设置的一致性级别的值小于设置的副本数量值，那么即便一些节点宕机，更新依然成功。</li>
<li><a href="https://mp.weixin.qq.com/s/yVbZfE7oWGmnfmcFTeSV4w" target="_blank" rel="external">Elasticsearch前沿：ES 5.x改进详解与ES6展望</a></li>
<li>一篇老文章<a href="http://www.infoq.com/cn/news/2017/04/2017-Serverless" target="_blank" rel="external">2017年会是Serverless爆发之年吗</a>,虽然已过0.75年，可见批评之声还是很多的。</li>
<li><a href="http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/" target="_blank" rel="external">SpringBoot源码分析之条件注解的底层实现</a></li>
<li><a href="http://hbasefly.com/2017/07/26/transactions-1/" target="_blank" rel="external">数据库事务系列－事务模型基础</a>, 好文，记忆不熟的可以常看，至少可以用来。</li>
<li><a href="http://www.hascode.com/2017/08/parameterized-tests-with-junit-5/" target="_blank" rel="external">Using JUnit 5 Parameterized Tests</a>系列文章</li>
<li><a href="http://www.cnblogs.com/yjmyzz/p/7390331.html" target="_blank" rel="external">@Transactional导致AbstractRoutingDataSource动态数据源无法切换的解决办法</a><br>在org.springframework.jdbc.datasource.DataSourceTransactionManager#doBegin 这个类的源代码中找到了答案<br>第7-16行，在开始一个事务前，如果当前上下文的连接对象为空，获取一个连接对象，然后保存起来，下次doBegin再调用时，就直接用这个连接了，根本不做任何切换(类似于缓存命中！）<br>这样就解释得通了： doSomeThing()方法被调用前，加了一段select方法，相当于已经切换到了slave从库，<br>然后再进入doBegin方法时，就直接拿这个从库的链接了，不再进行切换。<br>那为啥其它同样启用事务的方法，又能正常连到主库呢？同样的解释，因为这类方法前面，没有任何其它操作，<br>而xml中的动态数据源配置，默认连接的就是master主库，因此没有问题。</li>
<li><a href="https://www.zhihu.com/question/63946700" target="_blank" rel="external">如何评价波恩大学 Norbert Blum 关于 P≠NP 的证明</a>，这个链接跟进Norbert Blum 关于 P≠NP 的证明。<br>虽然每隔一段时间都会有证明冒出，虽然基本上认为不相等才是正道，还是有人不死心企图证明之。吾等表示围观还是要围观的。</li>
<li>最后，来一段中二的 <a href="https://thedailywtf.com/articles/ride-the-url-line" target="_blank" rel="external">Daily WTF 有趣的计算机幽默</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Tech/" rel="tag"># Tech</a>
          
            <a href="/tags/weeklyreading/" rel="tag"># weeklyreading</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/14/2017-08-14-a_dive_into_Shannon_entropy/" rel="next" title="信息熵的理解">
                <i class="fa fa-chevron-left"></i> 信息熵的理解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/26/2017-08-26-weekly_reading/" rel="prev" title="Weekly Reading 170825">
                Weekly Reading 170825 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/myLogo.png"
               alt="Thomas Lau" />
          <p class="site-author-name" itemprop="name">Thomas Lau</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ThomasLau" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/liuyongzhi0218" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thomas Lau</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
